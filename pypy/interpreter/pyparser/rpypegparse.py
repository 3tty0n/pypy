#!/usr/bin/env python
# @generated by pegen from ../data/python.gram

# Special RPython version

import sys

import io
import os
import sys

from pypy.interpreter.pyparser.pygram import tokens
from pypy.interpreter.pyparser.parser import Token
from pypy.interpreter.pyparser import pytokenizer as tokenize, pytoken
from pypy.interpreter.pyparser.error import SyntaxError, IndentationError

from pypy.interpreter.astcompiler import ast
from pypy.interpreter.astcompiler.astbuilder import parse_number
from pypy.interpreter.astcompiler import asthelpers # Side effects
from pypy.interpreter.astcompiler import consts, misc

Load = ast.Load
Store = ast.Store
Del = ast.Del

class MemoEntry(object):
    def __init__(self, methodname, tree, endmark, next):
        self.methodname = methodname
        self.tree = tree
        self.endmark = endmark
        self.next = next

def find_memo(tok, methodname):
    memo = tok.memo
    while memo:
        if memo.methodname == methodname:
            return memo
        memo = memo.next
    return None

def shorttok(tok):
    return "%-25.25s" % ("%s.%s: %s:%r" % (tok.lineno, tok.column, tok.token_type, tok.value))

def logger(method):
    """For non-memoized functions that we want to be logged.

    (In practice this is only non-leader left-recursive functions.)
    """
    method_name = method.__name__

    def logger_wrapper(self, *args):
        if not self._verbose:
            return method(self, *args)
        argsr = ",".join(repr(arg) for arg in args)
        fill = "  " * self._level
        print "%s%s(%s) .... (looking at %s)" % (fill, method_name, argsr, self.showpeek())
        self._level += 1
        tree = method(self, *args)
        self._level -= 1
        print "%s... %s(%s) --> %s" % (fill, method_name, argsr, tree)
        return tree

    logger_wrapper.__wrapped__ = method  # type: ignore
    return logger_wrapper


def memoize(method):
    """Memoize a symbol method."""
    method_name = method.__name__

    def memoize_wrapper(self):
        tok = self.peek()
        memo = find_memo(tok, method_name)
        # Fast path: cache hit, and not verbose.
        if memo:
            self._reset(memo.endmark)
            return memo.tree
        # Slow path: no cache hit, or verbose.
        verbose = self._verbose
        if verbose:
            fill = "  " * self._level
        if verbose:
            print "%s%s() .... (looking at %s)" % (fill, method_name, self.showpeek())
        self._level += 1
        tree = method(self)
        self._level -= 1
        if verbose:
            print "%s... %s() --> %s" % (fill, method_name, tree)
        endmark = self._mark()
        tok.memo = MemoEntry(method_name, tree, endmark, tok.memo)
        return tree

    memoize_wrapper.__wrapped__ = method  # type: ignore
    return memoize_wrapper


def memoize_left_rec(method):
    """Memoize a left-recursive symbol method."""
    method_name = method.__name__

    def memoize_left_rec_wrapper(self):
        mark = self._mark()
        tok = self.peek()
        memo = find_memo(tok, method_name)
        # Fast path: cache hit
        if memo:
            self._reset(memo.endmark)
            return memo.tree
        fill = "  " * self._level
        # key not in cache
        verbose = self._verbose
        if verbose:
            print "%s%s .... (looking at %s)" % (fill, method_name, self.showpeek())
        self._level += 1

        # For left-recursive rules we manipulate the cache and
        # loop until the rule shows no progress, then pick the
        # previous result.  For an explanation why this works, see
        # https://github.com/PhilippeSigaud/Pegged/wiki/Left-Recursion
        # (But we use the memoization cache instead of a static
        # variable; perhaps this is similar to a paper by Warth et al.
        # (http://web.cs.ucla.edu/~todd/research/pub.php?id=pepm08).

        # Prime the cache with a failure.
        memo = tok.memo = MemoEntry(method_name, None, mark, tok.memo)
        lastresult, lastmark = None, mark
        depth = 0
        if verbose:
            print "%sRecursive %s at %s depth %s" % (fill, method_name, mark, depth)

        while True:
            self._reset(mark)
            self.in_recursive_rule += 1
            try:
                result = method(self)
            finally:
                self.in_recursive_rule -= 1
            endmark = self._mark()
            depth += 1
            if verbose:
                print "%sRecursive %s at %s depth %s: %.200s to %s" % (fill, method_name, mark, depth, result, endmark)
            if not result:
                if verbose:
                    print "%sFail with %.200s to %s" % (fill, lastresult, lastmark)
                break
            if endmark <= lastmark:
                if verbose:
                    print "%sBailing with %.200s to %s" % (fill, lastresult, lastmark)
                break
            memo.tree, memo.endmark = lastresult, lastmark = result, endmark

        self._reset(lastmark)
        tree = lastresult

        self._level -= 1
        if verbose:
            print "%s... %s() --> %s [cached]" % (fill, method_name, tree)
        if tree:
            endmark = self._mark()
        else:
            endmark = mark
            self._reset(endmark)
        memo.tree, memo.endmark = tree, endmark
        return tree

    memoize_left_rec_wrapper.__wrapped__ = method  # type: ignore
    return memoize_left_rec_wrapper

class FStringAstBuilder(object):
    def __init__(self, space, parser, compile_info):
        self.space = space
        self.parser = parser
        self.compile_info = compile_info

    def recursive_parse_to_ast(self, str, info):
        from pypy.interpreter.pyparser import pytokenizer as tokenize
        tokenlist = tokenize.generate_tokens(str.splitlines(), 0)
        parser = PythonParser(self.space, tokenlist, self.compile_info, verbose=False)
        return parser.eval()

    def check_feature(self, condition, version, msg, n):
         if condition and self.compile_info.feature_version < version:
            return self.error(msg, n)

    def error_ast(self, msg, node):
        self.parser.raise_syntax_error_known_location_ast(msg, node)

    def error(self, msg, node):
        # XXX bit annoying
        tok = Token(node.type, node.value, node.lineno, node.column, node.line, node.end_lineno, node.end_column)
        self.parser.raise_syntax_error_known_location_ast(msg, node)

class Parser:
    """Parsing base class."""

    # KEYWORDS: ClassVar[Tuple[str, ...]]

    # SOFT_KEYWORDS: ClassVar[Tuple[str, ...]]

    def __init__(self, space, tokenlist, compile_info, verbose=False):
        # initialize tokenization stuff
        self._tokens = []
        self._lines = {}
        self._path = "" # XXX
        self.type_ignores = []
        self.compile_info = compile_info
        # delete final NEWLINE
        assert tokenlist[-2].token_type == pytoken.python_tokens['NEWLINE']
        del tokenlist[-2]
        for tok in tokenlist:
            # Special handling for TYPE_IGNOREs
            if tok.token_type == tokens.TYPE_IGNORE:
                self.type_ignores.append(tok)
                continue
            if tok.token_type in (tokens.NL, tokens.COMMENT):
                continue
            if tok.token_type == tokens.ERRORTOKEN and tok.value.isspace():
                continue
            if (
                tok.token_type == tokens.NEWLINE
                and self._tokens
                and self._tokens[-1].token_type == tokens.NEWLINE
            ):
                continue
            if tok.token_type == tokens.NAME:
                index = self.KEYWORD_INDICES.get(tok.value, -1)
                if index != -1:
                    tok.token_type = index
            tok.memo = None
            self._tokens.append(tok)
            if not self._path and tok.line:
                self._lines[tok.lineno] = tok.line
        self._index = 0
        self._highwatermark = 0

        # parser stuff
        self._verbose = verbose
        self._level = 0
        self._cache = {}
        # Integer tracking wether we are in a left recursive rule or not. Can be useful
        # for error reporting.
        self.in_recursive_rule = 0

        self.call_invalid_rules = False

        self.py_version = (3, 9)
        self.space = space


    def parse(self, entry):
        res = entry()
        if res is not None:
            return res
        self.reset()
        self.call_invalid_rules = True
        entry() # usually raises

    def reset(self):
        self._index = 0
        self._highwatermark = 0

        self._verbose = False
        self._level = 0
        self._cache = {}
        for tok in self._tokens:
            tok.memo = None
        self.in_recursive_rule = 0


    # tokenizer methods

    def _mark(self):
        return self._index

    def getnext(self):
        """Return the next token and updates the index."""
        cached = not self._index == len(self._tokens)
        tok = self.peek()
        self._index += 1
        self._highwatermark = max(self._highwatermark, self._index)
        if self._verbose:
            self.report(cached, False)
        return tok

    def peek(self):
        """Return the next token *without* updating the index."""
        assert self._index < len(self._tokens)
        return self._tokens[self._index]

    def diagnose(self):
        return self._tokens[self._highwatermark]

    def get_last_non_whitespace_token(self):
        for tok in reversed(self._tokens[: self._index]):
            if tok.token_type != tokens.ENDMARKER and (
                tok.token_type < tokens.NEWLINE or tok.token_type > tokens.DEDENT
            ):
                break
        return tok

    def get_lines(self, line_numbers):
        """Retrieve source lines corresponding to line numbers."""
        if self._lines:
            lines = self._lines
        else:
            n = len(line_numbers)
            lines = {}
            count = 0
            seen = 0
            with open(self._path) as f:
                for l in f:
                    count += 1
                    if count in line_numbers:
                        seen += 1
                        lines[count] = l
                        if seen == n:
                            break

        return [lines[n] for n in line_numbers]

    def _reset(self, index):
        if index == self._index:
            return
        assert 0 <= index <= len(self._tokens), (index, len(self._tokens))
        old_index = self._index
        self._index = index
        if self._verbose:
            self.report(True, index < old_index)

    def report(self, cached, back):
        if back:
            fill = "-" * self._index + "-"
        elif cached:
            fill = "-" * self._index + ">"
        else:
            fill = "-" * self._index + "*"
        if self._index == 0:
            print("%s (Bof)" % fill)
        else:
            tok = self._tokens[self._index - 1]
            print "%s %s" % (fill, shorttok(tok))
    # parser methods

    def start(self):
        pass

    def showpeek(self):
        tok = self.peek()
        return shorttok(tok)

    def name(self):
        tok = self.peek()
        if tok.token_type == tokens.NAME:
            self.getnext()
            return ast.Name(
                    id=self.new_identifier(tok.value),
                    ctx=Load,
                    lineno=tok.lineno,
                    col_offset=tok.column,
                    end_lineno=tok.end_lineno,
                    end_col_offset=tok.end_column,
                )
        return None

    def number(self):
        tok = self.peek()
        if tok.token_type == tokens.NUMBER:
            return self.getnext()
        return None

    def string(self):
        tok = self.peek()
        if tok.token_type == tokens.STRING:
            return self.getnext()
        return None

    def op(self):
        tok = self.peek()
        if tok.token_type == tokens.OP:
            return self.getnext()
        return None

    def type_comment(self):
        tok = self.peek()
        space = self.space
        if tok.token_type == tokens.TYPE_COMMENT:
            return space.newtext(self.getnext().value)
        return space.w_None

    def soft_keyword(self):
        tok = self.peek()
        if tok.token_type == tokens.NAME and tok.value in self.SOFT_KEYWORDS:
            return self.getnext()
        return None

    def expect(self, type):
        tok = self.peek()
        if tok.value == type:
            return self.getnext()
        if type in pytoken.python_opmap:
            if tok.token_type == pytoken.python_opmap[type]:
                return self.getnext()
        if type in pytoken.python_tokens:
            if tok.token_type == pytoken.python_tokens[type]:
                return self.getnext()
        if tok.token_type == tokens.OP and tok.value == type:
            return self.getnext()
        return None

    def expect_type(self, type):
        tok = self.peek()
        if tok.token_type == type:
            return self.getnext()

    def expect_forced(self, res, expectation):
        if res is None:
            self.raise_syntax_error("expected {expectation}")
        return res

    def positive_lookahead(self, func, *args):
        mark = self._mark()
        ok = func(*args)
        self._reset(mark)
        return ok

    def negative_lookahead(self, func, *args):
        mark = self._mark()
        ok = func(*args)
        self._reset(mark)
        return not ok

    def check_version(self, min_version, error_msg, node):
        """Check that the python version is high enough for a rule to apply.

        """
        if self.py_version >= min_version:
            return node
        else:
            self.raise_syntax_error_known_location_ast(
                "%s is only supported in Python %s and above." % (error_msg, min_version),
                node)

    def raise_indentation_error(self, msg):
        """Raise an indentation error."""
        self._raise_syntax_error(msg, cls=IndentationError)

    def get_expr_name(self, node):
        """Get a descriptive name for an expression."""
        return node._get_descr(self.space)

    def set_expr_context(self, node, context):
        """Set the context (Load, Store, Del) of an ast node."""
        try:
            node.set_context(self.space, context)
        except ast.UnacceptableExpressionContext as e:
            self.raise_syntax_error_known_location_ast(e.msg, e.node)
        except misc.ForbiddenNameAssignment as e:
            self.raise_syntax_error_known_location_ast("cannot assign to %s" % (e.name,), e.node)
        return node

    def check_for_forbidden_assignment_target(self, name):
        from pypy.interpreter.astcompiler import misc # Side effects
        if name is None:
            return None
        assert isinstance(name, ast.Name)
        id = name.id
        try:
            misc.check_forbidden_name(self.space, id)
        except misc.ForbiddenNameAssignment as e:
            self.raise_syntax_error_known_location_ast(
                "cannot assign to %s" % (e.name,), name)
        return id

    def check_repeated_keywords(self, args):
        if not args or not args[1]:
            return None
        keywords = args[1]
        if len(keywords) == 1:
            return keywords
        d = {}
        for keyword in keywords:
            if keyword.arg is None:
                # **arg
                continue
            if keyword.arg in d:
                self.raise_syntax_error_known_location_ast(
                    "keyword argument repeated: '%s'" % keyword.arg, keyword)
            d[keyword.arg] = None
        return keywords

    def new_identifier(self, name):
        return misc.new_identifier(self.space, name)

    def ensure_real(self, number_str):
        number = ast.literal_eval(number_str)
        if number is not complex:
            self.raise_syntax_error("real number required in complex literal")
        return number

    def ensure_imaginary(self, number_str):
        number = ast.literal_eval(number_str)
        if number is not complex:
            self.raise_syntax_error("imaginary  number required in complex literal")
        return number

    def generate_ast_for_string(self, tokens):
        """Generate AST nodes for strings."""
        from pypy.interpreter.pyparser.parser import Nonterminal, Terminal
        from pypy.interpreter.astcompiler.fstring import string_parse_literal
        # bit of a hack, allow fstrings to keep using the old interface
        return string_parse_literal(
            FStringAstBuilder(self.space, self, self.compile_info),
            Nonterminal(None, -5, [Terminal.fromtoken(None, tok) for tok in tokens]))

    def extract_import_level(self, tokens):
        """Extract the relative import level from the tokens preceding the module name.

        '.' count for one and '...' for 3.

        """
        level = 0
        for t in tokens:
            if t.value == ".":
                level += 1
            else:
                level += 3
        return level

    def set_decorators(self,
        target,
        decorators
    ):
        """Set the decorators on a function or class definition."""
        target.decorator_list = decorators
        return target

    def get_comparison_ops(self, pairs):
        return [op for op, _ in pairs]

    def get_comparators(self, pairs):
        return [comp for _, comp in pairs]

    def set_arg_type_comment(self, arg, type_comment):
        if type_comment or self.py_version < (3, 9):
            arg.type_comment = type_comment
        return arg

    def make_arguments(self,
        pos_only,
        pos_only_with_default,
        param_no_default,
        param_default,
        after_star,
    ):
        """Build a function definition arguments."""
        defaults = (
            [d for _, d in pos_only_with_default if d is not None]
            if pos_only_with_default else
            []
        )
        defaults += (
            [d for _, d in param_default if d is not None]
            if param_default else
            []
        )

        pos_only = pos_only or pos_only_with_default

        # Because we need to combine pos only with and without default even
        # the version with no default is a tuple
        pos_only = [p for p, _ in pos_only]
        params = (param_no_default or []) + ([p for p, _ in param_default] if param_default else [])

        # If after_star is None, make a default tuple
        after_star = after_star or (None, [], None)

        return ast.arguments(
            posonlyargs=pos_only,
            args=params if params else None,
            defaults=defaults if defaults else None,
            vararg=after_star[0],
            kwonlyargs=[p for p, _ in after_star[1]],
            kw_defaults=[d for _, d in after_star[1]],
            kwarg=after_star[2]
        )

    def _raise_syntax_error(
        self,
        message,
        start=None,
        end=None,
        cls=SyntaxError,
    ):
        line_from_token = start is None and end is None
        if start is None or end is None:
            tok = self.diagnose()
            start = start or (tok.lineno, tok.column)
            end = end or (tok.end_lineno, tok.end_column)

        if line_from_token:
            line = tok.line
        else:
            # End is used only to get the proper text
            line = "".join(
                self.get_lines(list(range(start[0], end[0] + 1)))
            )

        raise cls(
            message,
            start[0], start[1] + 1, line, self.compile_info.filename, lastlineno=end[0]
        )

    def raise_syntax_error_known_range(
        self,
        message,
        start_node,
        end_node,
    ):
        if not isinstance(start_node, ast.AST):
            start = start_node.lineno, start_node.col_offset
        else:
            start = start_node.lineno, start_node.col_offset

        if not isinstance(end_node, ast.AST):
            end = end_node.end_lineno, end_node.end_column
        else:
            end = end_node.end_lineno, end_node.end_col_offset

        self._raise_syntax_error(message, start, end)

    def raise_syntax_error_starting_from(
        self,
        message,
        start_node,
    ):
        if not isinstance(start_node, ast.AST):
            start = start_node.lineno, start_node.col_offset
        else:
            start = start_node.lineno, start_node.col_offset

        self._raise_syntax_error(message, start, None)

    def raise_syntax_error(self, message):
        self._raise_syntax_error(message, None, None)

    def raise_syntax_error_known_location_ast(
            self,
            message,
            node,
        ):
        """Raise a syntax error that occured at a given AST node."""
        assert isinstance(node, ast.AST)
        start = node.lineno, node.col_offset
        end = node.end_lineno, node.end_col_offset
        self._raise_syntax_error(message, start, end)

    def raise_syntax_error_known_location_tok(
            self,
            message,
            node,
        ):
        """Raise a syntax error that occured at a given AST node."""
        start = node.lineno, node.column
        end = node.end_lineno, node.end_column
        self._raise_syntax_error(message, start, end)


    def make_type_ignores(self):
        type_ignores = []
        for type_ignore in self.type_ignores:
            tag = self.space.newtext(type_ignore.value)
            type_ignores.append(ast.TypeIgnore(type_ignore.lineno, tag))
        return type_ignores

    def check_barry(self, tok):
        flufl = self.compile_info.flags & consts.CO_FUTURE_BARRY_AS_BDFL
        if flufl and tok.value == '!=':
            self.raise_syntax_error_known_location_tok("with Barry as BDFL, use '<>' instead of '!='", tok)
        elif not flufl and tok.value == '<>':
            self.raise_syntax_error_known_location_tok('invalid syntax', tok)
        return tok

    def kwarg_illegal_assignment(self, a, b):
        space = self.space
        if isinstance(a, ast.Constant):
            if space.is_w(a.value, space.w_True):
                error = "True"
            elif space.is_w(a.value, space.w_False):
                error = "False"
            elif space.is_w(a.value, space.w_None):
                error = "None"
            else:
                error = None
            if error is not None:
                self.raise_syntax_error_known_range(
                    "cannot assign to " + error, a, b,
                )
        self.raise_syntax_error_known_range(
            "expression cannot contain assignment, perhaps you meant \"==\"?", a, b,
        )

# Keywords and soft keywords are listed at the end of the parser definition.
class PythonParser(Parser):

    @logger
    def start(self): # type Optional[Any]
        # start: file
        mark = self._mark()
        file = self.file()
        if file:
            return file
        self._reset(mark)
        return None

    @logger
    def file(self): # type Optional[ast . Module]
        # file: statements? $
        mark = self._mark()
        a = self.statements()
        if True:
            _endmarker = self.expect_type(0)
            if _endmarker:
                return ast . Module ( body = a , type_ignores = self . make_type_ignores ( ) )
        self._reset(mark)
        return None

    @logger
    def interactive(self): # type Optional[ast . Interactive]
        # interactive: statement_newline
        mark = self._mark()
        a = self.statement_newline()
        if a:
            return ast . Interactive ( body = a )
        self._reset(mark)
        return None

    @logger
    def eval(self): # type Optional[ast . Expression]
        # eval: expressions NEWLINE* $
        mark = self._mark()
        a = self.expressions()
        if a:
            _loop0_1 = self._loop0_1()
            if True:
                _endmarker = self.expect_type(0)
                if _endmarker:
                    return ast . Expression ( body = a )
        self._reset(mark)
        return None

    @logger
    def func_type(self): # type Optional[ast . FunctionType]
        # func_type: '(' type_expressions? ')' '->' expression NEWLINE* $
        mark = self._mark()
        literal = self.expect_type(7)
        if literal:
            a = self.type_expressions()
            if True:
                literal_1 = self.expect_type(8)
                if literal_1:
                    literal_2 = self.expect_type(52)
                    if literal_2:
                        b = self.expression()
                        if b:
                            _loop0_2 = self._loop0_2()
                            if True:
                                _endmarker = self.expect_type(0)
                                if _endmarker:
                                    return ast . FunctionType ( argtypes = a , returns = b )
        self._reset(mark)
        return None

    @logger
    def fstring(self): # type Optional[ast . Expr]
        # fstring: star_expressions
        mark = self._mark()
        star_expressions = self.star_expressions()
        if star_expressions:
            return star_expressions
        self._reset(mark)
        return None

    @logger
    def statements(self): # type Optional[list]
        # statements: statement+
        mark = self._mark()
        a = self._loop1_3()
        if a:
            return [x for l in a for x in l]
        self._reset(mark)
        return None

    @logger
    def statement(self): # type Optional[list]
        # statement: compound_stmt | simple_stmts
        mark = self._mark()
        a = self.compound_stmt()
        if a:
            return [a]
        self._reset(mark)
        a = self.simple_stmts()
        if a:
            return a
        self._reset(mark)
        return None

    @logger
    def statement_newline(self): # type Optional[list]
        # statement_newline: compound_stmt NEWLINE | simple_stmts | NEWLINE | $
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.compound_stmt()
        if a:
            _newline = self.expect_type(4)
            if _newline:
                return [a]
        self._reset(mark)
        simple_stmts = self.simple_stmts()
        if simple_stmts:
            return simple_stmts
        self._reset(mark)
        _newline = self.expect_type(4)
        if _newline:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return [ast . Pass ( lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )]
        self._reset(mark)
        _endmarker = self.expect_type(0)
        if _endmarker:
            return None
        self._reset(mark)
        return None

    @logger
    def simple_stmts(self): # type Optional[list]
        # simple_stmts: simple_stmt !';' NEWLINE | ';'.simple_stmt+ ';'? NEWLINE
        mark = self._mark()
        a = self.simple_stmt()
        if a:
            
            if self.negative_lookahead(self.expect_type, 13):
                _newline = self.expect_type(4)
                if _newline:
                    return [a]
        self._reset(mark)
        a = self._gather_4()
        if a:
            opt = self.expect_type(13)
            if True:
                _newline = self.expect_type(4)
                if _newline:
                    return a
        self._reset(mark)
        return None

    @memoize
    def simple_stmt(self): # type Optional[Any]
        # simple_stmt: assignment | star_expressions | &'return' return_stmt | &('import' | 'from') import_stmt | &'raise' raise_stmt | 'pass' | &'del' del_stmt | &'yield' yield_stmt | &'assert' assert_stmt | 'break' | 'continue' | &'global' global_stmt | &'nonlocal' nonlocal_stmt
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        assignment = self.assignment()
        if assignment:
            return assignment
        self._reset(mark)
        e = self.star_expressions()
        if e:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . Expr ( value = e , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        
        if self.positive_lookahead(self.expect_type, 499):
            return_stmt = self.return_stmt()
            if return_stmt:
                return return_stmt
        self._reset(mark)
        
        if self.positive_lookahead(self._tmp_6, ):
            import_stmt = self.import_stmt()
            if import_stmt:
                return import_stmt
        self._reset(mark)
        
        if self.positive_lookahead(self.expect_type, 500):
            raise_stmt = self.raise_stmt()
            if raise_stmt:
                return raise_stmt
        self._reset(mark)
        literal = self.expect_type(501)
        if literal:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . Pass ( lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        
        if self.positive_lookahead(self.expect_type, 502):
            del_stmt = self.del_stmt()
            if del_stmt:
                return del_stmt
        self._reset(mark)
        
        if self.positive_lookahead(self.expect_type, 503):
            yield_stmt = self.yield_stmt()
            if yield_stmt:
                return yield_stmt
        self._reset(mark)
        
        if self.positive_lookahead(self.expect_type, 504):
            assert_stmt = self.assert_stmt()
            if assert_stmt:
                return assert_stmt
        self._reset(mark)
        literal = self.expect_type(505)
        if literal:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . Break ( lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(506)
        if literal:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . Continue ( lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        
        if self.positive_lookahead(self.expect_type, 507):
            global_stmt = self.global_stmt()
            if global_stmt:
                return global_stmt
        self._reset(mark)
        
        if self.positive_lookahead(self.expect_type, 508):
            nonlocal_stmt = self.nonlocal_stmt()
            if nonlocal_stmt:
                return nonlocal_stmt
        self._reset(mark)
        return None

    @logger
    def compound_stmt(self): # type Optional[Any]
        # compound_stmt: &('def' | '@' | ASYNC) function_def | &'if' if_stmt | &('class' | '@') class_def | &('with' | ASYNC) with_stmt | &('for' | ASYNC) for_stmt | &'try' try_stmt | &'while' while_stmt | match_stmt
        mark = self._mark()
        
        if self.positive_lookahead(self._tmp_7, ):
            function_def = self.function_def()
            if function_def:
                return function_def
        self._reset(mark)
        
        if self.positive_lookahead(self.expect_type, 509):
            if_stmt = self.if_stmt()
            if if_stmt:
                return if_stmt
        self._reset(mark)
        
        if self.positive_lookahead(self._tmp_8, ):
            class_def = self.class_def()
            if class_def:
                return class_def
        self._reset(mark)
        
        if self.positive_lookahead(self._tmp_9, ):
            with_stmt = self.with_stmt()
            if with_stmt:
                return with_stmt
        self._reset(mark)
        
        if self.positive_lookahead(self._tmp_10, ):
            for_stmt = self.for_stmt()
            if for_stmt:
                return for_stmt
        self._reset(mark)
        
        if self.positive_lookahead(self.expect_type, 510):
            try_stmt = self.try_stmt()
            if try_stmt:
                return try_stmt
        self._reset(mark)
        
        if self.positive_lookahead(self.expect_type, 511):
            while_stmt = self.while_stmt()
            if while_stmt:
                return while_stmt
        self._reset(mark)
        match_stmt = self.match_stmt()
        if match_stmt:
            return match_stmt
        self._reset(mark)
        return None

    @logger
    def assignment(self): # type Optional[Any]
        # assignment: NAME ':' expression ['=' annotated_rhs] | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs] | ((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT? | single_target augassign ~ (yield_expr | star_expressions) | invalid_assignment
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.name()
        if a:
            literal = self.expect_type(11)
            if literal:
                b = self.expression()
                if b:
                    c = self._tmp_11()
                    if True:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return self . check_version ( ( 3 , 6 ) , "Variable annotation syntax is" , ast . AnnAssign ( target = self . set_expr_context ( a , Store ) , annotation = b , value = c , simple = 1 , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , ) )
        self._reset(mark)
        a = self._tmp_12()
        if a:
            literal = self.expect_type(11)
            if literal:
                b = self.expression()
                if b:
                    c = self._tmp_13()
                    if True:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return self . check_version ( ( 3 , 6 ) , "Variable annotation syntax is" , ast . AnnAssign ( target = a , annotation = b , value = c , simple = 0 , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , ) )
        self._reset(mark)
        a = self._loop1_14()
        if a:
            b = self._tmp_15()
            if b:
                
                if self.negative_lookahead(self.expect_type, 22):
                    tc = self.type_comment()
                    if True:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . Assign ( targets = a , value = b , type_comment = tc , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        cut = False
        a = self.single_target()
        if a:
            b = self.augassign()
            if b:
                cut = True
                if cut:
                    c = self._tmp_16()
                    if c:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . AugAssign ( target = a , op = b , value = c , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        if cut: return None
        if self.call_invalid_rules:
            invalid_assignment = self.invalid_assignment()
            if invalid_assignment:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def annotated_rhs(self): # type Optional[Any]
        # annotated_rhs: yield_expr | star_expressions
        mark = self._mark()
        yield_expr = self.yield_expr()
        if yield_expr:
            return yield_expr
        self._reset(mark)
        star_expressions = self.star_expressions()
        if star_expressions:
            return star_expressions
        self._reset(mark)
        return None

    @logger
    def augassign(self): # type Optional[Any]
        # augassign: '+=' | '-=' | '*=' | '@=' | '/=' | '%=' | '&=' | '|=' | '^=' | '<<=' | '>>=' | '**=' | '//='
        mark = self._mark()
        literal = self.expect_type(37)
        if literal:
            return ast . Add
        self._reset(mark)
        literal = self.expect_type(38)
        if literal:
            return ast . Sub
        self._reset(mark)
        literal = self.expect_type(39)
        if literal:
            return ast . Mult
        self._reset(mark)
        literal = self.expect_type(51)
        if literal:
            return self . check_version ( ( 3 , 5 ) , "The '@' operator is" , ast . MatMult )
        self._reset(mark)
        literal = self.expect_type(40)
        if literal:
            return ast . Div
        self._reset(mark)
        literal = self.expect_type(41)
        if literal:
            return ast . Mod
        self._reset(mark)
        literal = self.expect_type(42)
        if literal:
            return ast . BitAnd
        self._reset(mark)
        literal = self.expect_type(43)
        if literal:
            return ast . BitOr
        self._reset(mark)
        literal = self.expect_type(44)
        if literal:
            return ast . BitXor
        self._reset(mark)
        literal = self.expect_type(45)
        if literal:
            return ast . LShift
        self._reset(mark)
        literal = self.expect_type(46)
        if literal:
            return ast . RShift
        self._reset(mark)
        literal = self.expect_type(47)
        if literal:
            return ast . Pow
        self._reset(mark)
        literal = self.expect_type(49)
        if literal:
            return ast . FloorDiv
        self._reset(mark)
        return None

    @logger
    def return_stmt(self): # type Optional[ast . Return]
        # return_stmt: 'return' star_expressions?
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(499)
        if literal:
            a = self.star_expressions()
            if True:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . Return ( value = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def raise_stmt(self): # type Optional[ast . Raise]
        # raise_stmt: 'raise' expression ['from' expression] | 'raise'
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(500)
        if literal:
            a = self.expression()
            if a:
                b = self._tmp_17()
                if True:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . Raise ( exc = a , cause = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(500)
        if literal:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . Raise ( exc = None , cause = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def global_stmt(self): # type Optional[ast . Global]
        # global_stmt: 'global' ','.NAME+
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(507)
        if literal:
            a = self._gather_18()
            if a:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . Global ( names = [n . id for n in a] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def nonlocal_stmt(self): # type Optional[ast . Nonlocal]
        # nonlocal_stmt: 'nonlocal' ','.NAME+
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(508)
        if literal:
            a = self._gather_20()
            if a:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . Nonlocal ( names = [n . id for n in a] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def del_stmt(self): # type Optional[ast . Delete]
        # del_stmt: 'del' del_targets &(';' | NEWLINE) | invalid_del_stmt
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(502)
        if literal:
            a = self.del_targets()
            if a:
                
                if self.positive_lookahead(self._tmp_22, ):
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . Delete ( targets = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_del_stmt = self.invalid_del_stmt()
            if invalid_del_stmt:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def yield_stmt(self): # type Optional[ast . Expr]
        # yield_stmt: yield_expr
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        y = self.yield_expr()
        if y:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . Expr ( value = y , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def assert_stmt(self): # type Optional[ast . Assert]
        # assert_stmt: 'assert' expression [',' expression]
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(504)
        if literal:
            a = self.expression()
            if a:
                b = self._tmp_23()
                if True:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . Assert ( test = a , msg = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def import_stmt(self): # type Optional[ast . Import]
        # import_stmt: import_name | import_from
        mark = self._mark()
        import_name = self.import_name()
        if import_name:
            return import_name
        self._reset(mark)
        import_from = self.import_from()
        if import_from:
            return import_from
        self._reset(mark)
        return None

    @logger
    def import_name(self): # type Optional[ast . Import]
        # import_name: 'import' dotted_as_names
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(512)
        if literal:
            a = self.dotted_as_names()
            if a:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . Import ( names = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def import_from(self): # type Optional[ast . ImportFrom]
        # import_from: 'from' (('.' | '...'))* dotted_name 'import' import_from_targets | 'from' (('.' | '...'))+ 'import' import_from_targets
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(513)
        if literal:
            a = self._loop0_24()
            if True:
                b = self.dotted_name()
                if b:
                    literal_1 = self.expect_type(512)
                    if literal_1:
                        c = self.import_from_targets()
                        if c:
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return ast . ImportFrom ( module = b , names = c , level = self . extract_import_level ( a ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(513)
        if literal:
            a = self._loop1_25()
            if a:
                literal_1 = self.expect_type(512)
                if literal_1:
                    b = self.import_from_targets()
                    if b:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . ImportFrom ( module = None , names = b , level = self . extract_import_level ( a ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def import_from_targets(self): # type Optional[List [ast . alias]]
        # import_from_targets: '(' import_from_as_names ','? ')' | import_from_as_names !',' | '*' | invalid_import_from_targets
        mark = self._mark()
        literal = self.expect_type(7)
        if literal:
            a = self.import_from_as_names()
            if a:
                opt = self.expect_type(12)
                if True:
                    literal_1 = self.expect_type(8)
                    if literal_1:
                        return a
        self._reset(mark)
        import_from_as_names = self.import_from_as_names()
        if import_from_as_names:
            
            if self.negative_lookahead(self.expect_type, 12):
                return import_from_as_names
        self._reset(mark)
        literal = self.expect_type(16)
        if literal:
            return [ast . alias ( name = "*" , asname = None )]
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_import_from_targets = self.invalid_import_from_targets()
            if invalid_import_from_targets:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def import_from_as_names(self): # type Optional[List [ast . alias]]
        # import_from_as_names: ','.import_from_as_name+
        mark = self._mark()
        a = self._gather_26()
        if a:
            return a
        self._reset(mark)
        return None

    @logger
    def import_from_as_name(self): # type Optional[ast . alias]
        # import_from_as_name: NAME ['as' NAME]
        mark = self._mark()
        a = self.name()
        if a:
            b = self._tmp_28()
            if True:
                return ast . alias ( name = self . check_for_forbidden_assignment_target ( a ) , asname = self . check_for_forbidden_assignment_target ( b ) )
        self._reset(mark)
        return None

    @logger
    def dotted_as_names(self): # type Optional[List [ast . alias]]
        # dotted_as_names: ','.dotted_as_name+
        mark = self._mark()
        a = self._gather_29()
        if a:
            return a
        self._reset(mark)
        return None

    @logger
    def dotted_as_name(self): # type Optional[ast . alias]
        # dotted_as_name: dotted_name ['as' NAME]
        mark = self._mark()
        a = self.dotted_name()
        if a:
            b = self._tmp_31()
            if True:
                return ast . alias ( name = a , asname = self . check_for_forbidden_assignment_target ( b ) )
        self._reset(mark)
        return None

    @memoize_left_rec
    def dotted_name(self): # type Optional[str]
        # dotted_name: NAME !'.' | dotted_name '.' NAME | NAME
        mark = self._mark()
        a = self.name()
        if a:
            
            if self.negative_lookahead(self.expect_type, 23):
                return self . check_for_forbidden_assignment_target ( a )
        self._reset(mark)
        a = self.dotted_name()
        if a:
            literal = self.expect_type(23)
            if literal:
                b = self.name()
                if b:
                    return a + "." + b . id
        self._reset(mark)
        a = self.name()
        if a:
            return a . id
        self._reset(mark)
        return None

    @memoize
    def block(self): # type Optional[list]
        # block: NEWLINE INDENT statements DEDENT | simple_stmts | invalid_block
        mark = self._mark()
        _newline = self.expect_type(4)
        if _newline:
            _indent = self.expect_type(5)
            if _indent:
                a = self.statements()
                if a:
                    _dedent = self.expect_type(6)
                    if _dedent:
                        return a
        self._reset(mark)
        simple_stmts = self.simple_stmts()
        if simple_stmts:
            return simple_stmts
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_block = self.invalid_block()
            if invalid_block:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def decorators(self): # type Optional[Any]
        # decorators: decorator+
        mark = self._mark()
        _loop1_32 = self._loop1_32()
        if _loop1_32:
            return _loop1_32
        self._reset(mark)
        return None

    @logger
    def decorator(self): # type Optional[Any]
        # decorator: ('@' dec_maybe_call NEWLINE) | ('@' named_expression NEWLINE)
        mark = self._mark()
        a = self._tmp_33()
        if a:
            return a
        self._reset(mark)
        a = self._tmp_34()
        if a:
            return self . check_version ( ( 3 , 9 ) , "Generic decorator are" , a )
        self._reset(mark)
        return None

    @logger
    def dec_maybe_call(self): # type Optional[Any]
        # dec_maybe_call: dec_primary '(' arguments? ')' | dec_primary
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        dn = self.dec_primary()
        if dn:
            literal = self.expect_type(7)
            if literal:
                z = self.arguments()
                if True:
                    literal_1 = self.expect_type(8)
                    if literal_1:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . Call ( func = dn , args = z [0] if z and z [0] else None , keywords = self . check_repeated_keywords ( z ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        dec_primary = self.dec_primary()
        if dec_primary:
            return dec_primary
        self._reset(mark)
        return None

    @memoize_left_rec
    def dec_primary(self): # type Optional[Any]
        # dec_primary: dec_primary '.' NAME | NAME
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.dec_primary()
        if a:
            literal = self.expect_type(23)
            if literal:
                b = self.name()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . Attribute ( value = a , attr = b . id , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.name()
        if a:
            return a
        self._reset(mark)
        return None

    @logger
    def class_def(self): # type Optional[ast . ClassDef]
        # class_def: decorators class_def_raw | class_def_raw
        mark = self._mark()
        a = self.decorators()
        if a:
            b = self.class_def_raw()
            if b:
                return self . set_decorators ( b , a )
        self._reset(mark)
        class_def_raw = self.class_def_raw()
        if class_def_raw:
            return class_def_raw
        self._reset(mark)
        return None

    @logger
    def class_def_raw(self): # type Optional[ast . ClassDef]
        # class_def_raw: invalid_class_def_raw | 'class' NAME ['(' arguments? ')'] &&':' block
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        if self.call_invalid_rules:
            invalid_class_def_raw = self.invalid_class_def_raw()
            if invalid_class_def_raw:
                return None  # pragma: no cover
            self._reset(mark)
        literal = self.expect_type(514)
        if literal:
            a = self.name()
            if a:
                b = self._tmp_35()
                if True:
                    literal_1 = self.expect_forced(self.expect_type(11), "':'")
                    if literal_1:
                        c = self.block()
                        if c:
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return ast . ClassDef ( self . check_for_forbidden_assignment_target ( a ) , bases = b [0] if b else None , keywords = b [1] if b else None , body = c , decorator_list = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , )
        self._reset(mark)
        return None

    @logger
    def function_def(self): # type Optional[Union [ast . FunctionDef , ast . AsyncFunctionDef]]
        # function_def: decorators function_def_raw | function_def_raw
        mark = self._mark()
        d = self.decorators()
        if d:
            f = self.function_def_raw()
            if f:
                return self . set_decorators ( f , d )
        self._reset(mark)
        f = self.function_def_raw()
        if f:
            return self . set_decorators ( f , None )
        self._reset(mark)
        return None

    @logger
    def function_def_raw(self): # type Optional[Union [ast . FunctionDef , ast . AsyncFunctionDef]]
        # function_def_raw: invalid_def_raw | 'def' NAME '(' params? ')' ['->' expression] &&':' func_type_comment? block | ASYNC 'def' NAME '(' params? ')' ['->' expression] &&':' func_type_comment? block
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        if self.call_invalid_rules:
            invalid_def_raw = self.invalid_def_raw()
            if invalid_def_raw:
                return None  # pragma: no cover
            self._reset(mark)
        literal = self.expect_type(515)
        if literal:
            n = self.name()
            if n:
                literal_1 = self.expect_type(7)
                if literal_1:
                    params = self.params()
                    if True:
                        literal_2 = self.expect_type(8)
                        if literal_2:
                            a = self._tmp_36()
                            if True:
                                literal_3 = self.expect_forced(self.expect_type(11), "':'")
                                if literal_3:
                                    tc = self.func_type_comment()
                                    if True:
                                        b = self.block()
                                        if b:
                                            tok = self.get_last_non_whitespace_token()
                                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                                            return ast . FunctionDef ( name = self . check_for_forbidden_assignment_target ( n ) , args = params or self . make_arguments ( None , [] , None , [] , None ) , returns = a , body = b , decorator_list = None , type_comment = tc , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , )
        self._reset(mark)
        _async = self.expect_type(58)
        if _async:
            literal = self.expect_type(515)
            if literal:
                n = self.name()
                if n:
                    literal_1 = self.expect_type(7)
                    if literal_1:
                        params = self.params()
                        if True:
                            literal_2 = self.expect_type(8)
                            if literal_2:
                                a = self._tmp_37()
                                if True:
                                    literal_3 = self.expect_forced(self.expect_type(11), "':'")
                                    if literal_3:
                                        tc = self.func_type_comment()
                                        if True:
                                            b = self.block()
                                            if b:
                                                tok = self.get_last_non_whitespace_token()
                                                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                                                return self . check_version ( ( 3 , 5 ) , "Async functions are" , ast . AsyncFunctionDef ( name = self . check_for_forbidden_assignment_target ( n ) , args = params or self . make_arguments ( None , [] , None , [] , None ) , returns = a , body = b , decorator_list = None , type_comment = tc , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , ) )
        self._reset(mark)
        return None

    @logger
    def params(self): # type Optional[Any]
        # params: invalid_parameters | parameters
        mark = self._mark()
        if self.call_invalid_rules:
            invalid_parameters = self.invalid_parameters()
            if invalid_parameters:
                return None  # pragma: no cover
            self._reset(mark)
        parameters = self.parameters()
        if parameters:
            return parameters
        self._reset(mark)
        return None

    @logger
    def parameters(self): # type Optional[ast . arguments]
        # parameters: slash_no_default param_no_default* param_with_default* star_etc? | slash_with_default param_with_default* star_etc? | param_no_default+ param_with_default* star_etc? | param_with_default+ star_etc? | star_etc
        mark = self._mark()
        a = self.slash_no_default()
        if a:
            b = self._loop0_38()
            if True:
                c = self._loop0_39()
                if True:
                    d = self.star_etc()
                    if True:
                        return self . check_version ( ( 3 , 8 ) , "Positional only arguments are" , self . make_arguments ( a , [] , b , c , d ) )
        self._reset(mark)
        a = self.slash_with_default()
        if a:
            b = self._loop0_40()
            if True:
                c = self.star_etc()
                if True:
                    return self . check_version ( ( 3 , 8 ) , "Positional only arguments are" , self . make_arguments ( None , a , None , b , c ) , )
        self._reset(mark)
        a = self._loop1_41()
        if a:
            b = self._loop0_42()
            if True:
                c = self.star_etc()
                if True:
                    return self . make_arguments ( None , [] , a , b , c )
        self._reset(mark)
        a = self._loop1_43()
        if a:
            b = self.star_etc()
            if True:
                return self . make_arguments ( None , [] , None , a , b )
        self._reset(mark)
        a = self.star_etc()
        if a:
            return self . make_arguments ( None , [] , None , None , a )
        self._reset(mark)
        return None

    @logger
    def slash_no_default(self): # type Optional[List [Tuple [ast . arg , None]]]
        # slash_no_default: param_no_default+ '/' ',' | param_no_default+ '/' &')'
        mark = self._mark()
        a = self._loop1_44()
        if a:
            literal = self.expect_type(17)
            if literal:
                literal_1 = self.expect_type(12)
                if literal_1:
                    return [( p , None ) for p in a]
        self._reset(mark)
        a = self._loop1_45()
        if a:
            literal = self.expect_type(17)
            if literal:
                
                if self.positive_lookahead(self.expect_type, 8):
                    return [( p , None ) for p in a]
        self._reset(mark)
        return None

    @logger
    def slash_with_default(self): # type Optional[List [Tuple [ast . arg , Any]]]
        # slash_with_default: param_no_default* param_with_default+ '/' ',' | param_no_default* param_with_default+ '/' &')'
        mark = self._mark()
        a = self._loop0_46()
        if True:
            b = self._loop1_47()
            if b:
                literal = self.expect_type(17)
                if literal:
                    literal_1 = self.expect_type(12)
                    if literal_1:
                        return ( [( p , None ) for p in a] if a else [] ) + b
        self._reset(mark)
        a = self._loop0_48()
        if True:
            b = self._loop1_49()
            if b:
                literal = self.expect_type(17)
                if literal:
                    
                    if self.positive_lookahead(self.expect_type, 8):
                        return ( [( p , None ) for p in a] if a else [] ) + b
        self._reset(mark)
        return None

    @logger
    def star_etc(self): # type Optional[Tuple [Optional [ast . arg] , List [Tuple [ast . arg , Any]] , Optional [ast . arg]]]
        # star_etc: '*' param_no_default param_maybe_default* kwds? | '*' ',' param_maybe_default+ kwds? | kwds | invalid_star_etc
        mark = self._mark()
        literal = self.expect_type(16)
        if literal:
            a = self.param_no_default()
            if a:
                b = self._loop0_50()
                if True:
                    c = self.kwds()
                    if True:
                        return ( a , b , c )
        self._reset(mark)
        literal = self.expect_type(16)
        if literal:
            literal_1 = self.expect_type(12)
            if literal_1:
                b = self._loop1_51()
                if b:
                    c = self.kwds()
                    if True:
                        return ( None , b , c )
        self._reset(mark)
        a = self.kwds()
        if a:
            return ( None , [] , a )
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_star_etc = self.invalid_star_etc()
            if invalid_star_etc:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def kwds(self): # type Optional[Any]
        # kwds: '**' param_no_default
        mark = self._mark()
        literal = self.expect_type(36)
        if literal:
            a = self.param_no_default()
            if a:
                return a
        self._reset(mark)
        return None

    @logger
    def param_no_default(self): # type Optional[ast . arg]
        # param_no_default: param ',' TYPE_COMMENT? | param TYPE_COMMENT? &')'
        mark = self._mark()
        a = self.param()
        if a:
            literal = self.expect_type(12)
            if literal:
                tc = self.type_comment()
                if True:
                    return self . set_arg_type_comment ( a , tc )
        self._reset(mark)
        a = self.param()
        if a:
            tc = self.type_comment()
            if True:
                
                if self.positive_lookahead(self.expect_type, 8):
                    return self . set_arg_type_comment ( a , tc )
        self._reset(mark)
        return None

    @logger
    def param_with_default(self): # type Optional[Tuple [ast . arg , Any]]
        # param_with_default: param default ',' TYPE_COMMENT? | param default TYPE_COMMENT? &')'
        mark = self._mark()
        a = self.param()
        if a:
            c = self.default()
            if c:
                literal = self.expect_type(12)
                if literal:
                    tc = self.type_comment()
                    if True:
                        return ( self . set_arg_type_comment ( a , tc ) , c )
        self._reset(mark)
        a = self.param()
        if a:
            c = self.default()
            if c:
                tc = self.type_comment()
                if True:
                    
                    if self.positive_lookahead(self.expect_type, 8):
                        return ( self . set_arg_type_comment ( a , tc ) , c )
        self._reset(mark)
        return None

    @logger
    def param_maybe_default(self): # type Optional[Tuple [ast . arg , Any]]
        # param_maybe_default: param default? ',' TYPE_COMMENT? | param default? TYPE_COMMENT? &')'
        mark = self._mark()
        a = self.param()
        if a:
            c = self.default()
            if True:
                literal = self.expect_type(12)
                if literal:
                    tc = self.type_comment()
                    if True:
                        return ( self . set_arg_type_comment ( a , tc ) , c )
        self._reset(mark)
        a = self.param()
        if a:
            c = self.default()
            if True:
                tc = self.type_comment()
                if True:
                    
                    if self.positive_lookahead(self.expect_type, 8):
                        return ( self . set_arg_type_comment ( a , tc ) , c )
        self._reset(mark)
        return None

    @logger
    def param(self): # type Optional[Any]
        # param: NAME annotation?
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.name()
        if a:
            b = self.annotation()
            if True:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . arg ( arg = self . check_for_forbidden_assignment_target ( a ) , annotation = b , type_comment = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def annotation(self): # type Optional[Any]
        # annotation: ':' expression
        mark = self._mark()
        literal = self.expect_type(11)
        if literal:
            a = self.expression()
            if a:
                return a
        self._reset(mark)
        return None

    @logger
    def default(self): # type Optional[Any]
        # default: '=' expression
        mark = self._mark()
        literal = self.expect_type(22)
        if literal:
            a = self.expression()
            if a:
                return a
        self._reset(mark)
        return None

    @logger
    def if_stmt(self): # type Optional[ast . If]
        # if_stmt: invalid_if_stmt | 'if' named_expression ':' block elif_stmt | 'if' named_expression ':' block else_block?
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        if self.call_invalid_rules:
            invalid_if_stmt = self.invalid_if_stmt()
            if invalid_if_stmt:
                return None  # pragma: no cover
            self._reset(mark)
        literal = self.expect_type(509)
        if literal:
            a = self.named_expression()
            if a:
                literal_1 = self.expect_type(11)
                if literal_1:
                    b = self.block()
                    if b:
                        c = self.elif_stmt()
                        if c:
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return ast . If ( test = a , body = b , orelse = c , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(509)
        if literal:
            a = self.named_expression()
            if a:
                literal_1 = self.expect_type(11)
                if literal_1:
                    b = self.block()
                    if b:
                        c = self.else_block()
                        if True:
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return ast . If ( test = a , body = b , orelse = c , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def elif_stmt(self): # type Optional[List [ast . If]]
        # elif_stmt: invalid_elif_stmt | 'elif' named_expression ':' block elif_stmt | 'elif' named_expression ':' block else_block?
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        if self.call_invalid_rules:
            invalid_elif_stmt = self.invalid_elif_stmt()
            if invalid_elif_stmt:
                return None  # pragma: no cover
            self._reset(mark)
        literal = self.expect_type(516)
        if literal:
            a = self.named_expression()
            if a:
                literal_1 = self.expect_type(11)
                if literal_1:
                    b = self.block()
                    if b:
                        c = self.elif_stmt()
                        if c:
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return [ast . If ( test = a , body = b , orelse = c , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )]
        self._reset(mark)
        literal = self.expect_type(516)
        if literal:
            a = self.named_expression()
            if a:
                literal_1 = self.expect_type(11)
                if literal_1:
                    b = self.block()
                    if b:
                        c = self.else_block()
                        if True:
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return [ast . If ( test = a , body = b , orelse = c , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )]
        self._reset(mark)
        return None

    @logger
    def else_block(self): # type Optional[list]
        # else_block: invalid_else_stmt | 'else' &&':' block
        mark = self._mark()
        if self.call_invalid_rules:
            invalid_else_stmt = self.invalid_else_stmt()
            if invalid_else_stmt:
                return None  # pragma: no cover
            self._reset(mark)
        literal = self.expect_type(517)
        if literal:
            literal_1 = self.expect_forced(self.expect_type(11), "':'")
            if literal_1:
                b = self.block()
                if b:
                    return b
        self._reset(mark)
        return None

    @logger
    def while_stmt(self): # type Optional[ast . While]
        # while_stmt: invalid_while_stmt | 'while' named_expression ':' block else_block?
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        if self.call_invalid_rules:
            invalid_while_stmt = self.invalid_while_stmt()
            if invalid_while_stmt:
                return None  # pragma: no cover
            self._reset(mark)
        literal = self.expect_type(511)
        if literal:
            a = self.named_expression()
            if a:
                literal_1 = self.expect_type(11)
                if literal_1:
                    b = self.block()
                    if b:
                        c = self.else_block()
                        if True:
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return ast . While ( test = a , body = b , orelse = c , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def for_stmt(self): # type Optional[Union [ast . For , ast . AsyncFor]]
        # for_stmt: invalid_for_stmt | 'for' star_targets 'in' ~ star_expressions &&':' TYPE_COMMENT? block else_block? | ASYNC 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block? | invalid_for_target
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        if self.call_invalid_rules:
            invalid_for_stmt = self.invalid_for_stmt()
            if invalid_for_stmt:
                return None  # pragma: no cover
            self._reset(mark)
        cut = False
        literal = self.expect_type(518)
        if literal:
            t = self.star_targets()
            if t:
                literal_1 = self.expect_type(519)
                if literal_1:
                    cut = True
                    if cut:
                        ex = self.star_expressions()
                        if ex:
                            literal_2 = self.expect_forced(self.expect_type(11), "':'")
                            if literal_2:
                                tc = self.type_comment()
                                if True:
                                    b = self.block()
                                    if b:
                                        el = self.else_block()
                                        if True:
                                            tok = self.get_last_non_whitespace_token()
                                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                                            return ast . For ( target = t , iter = ex , body = b , orelse = el , type_comment = tc , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        if cut: return None
        cut = False
        _async = self.expect_type(58)
        if _async:
            literal = self.expect_type(518)
            if literal:
                t = self.star_targets()
                if t:
                    literal_1 = self.expect_type(519)
                    if literal_1:
                        cut = True
                        if cut:
                            ex = self.star_expressions()
                            if ex:
                                literal_2 = self.expect_type(11)
                                if literal_2:
                                    tc = self.type_comment()
                                    if True:
                                        b = self.block()
                                        if b:
                                            el = self.else_block()
                                            if True:
                                                tok = self.get_last_non_whitespace_token()
                                                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                                                return self . check_version ( ( 3 , 5 ) , "Async for loops are" , ast . AsyncFor ( target = t , iter = ex , body = b , orelse = el , type_comment = tc , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) )
        self._reset(mark)
        if cut: return None
        if self.call_invalid_rules:
            invalid_for_target = self.invalid_for_target()
            if invalid_for_target:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def with_stmt(self): # type Optional[Union [ast . With , ast . AsyncWith]]
        # with_stmt: invalid_with_stmt_indent | 'with' '(' ','.with_item+ ','? ')' ':' block | 'with' ','.with_item+ ':' TYPE_COMMENT? block | ASYNC 'with' '(' ','.with_item+ ','? ')' ':' block | ASYNC 'with' ','.with_item+ ':' TYPE_COMMENT? block | invalid_with_stmt
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        if self.call_invalid_rules:
            invalid_with_stmt_indent = self.invalid_with_stmt_indent()
            if invalid_with_stmt_indent:
                return None  # pragma: no cover
            self._reset(mark)
        literal = self.expect_type(520)
        if literal:
            literal_1 = self.expect_type(7)
            if literal_1:
                a = self._gather_52()
                if a:
                    opt = self.expect_type(12)
                    if True:
                        literal_2 = self.expect_type(8)
                        if literal_2:
                            literal_3 = self.expect_type(11)
                            if literal_3:
                                b = self.block()
                                if b:
                                    tok = self.get_last_non_whitespace_token()
                                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                                    return self . check_version ( ( 3 , 9 ) , "Parenthesized with items" , ast . With ( items = a , body = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) )
        self._reset(mark)
        literal = self.expect_type(520)
        if literal:
            a = self._gather_54()
            if a:
                literal_1 = self.expect_type(11)
                if literal_1:
                    tc = self.type_comment()
                    if True:
                        b = self.block()
                        if b:
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return ast . With ( items = a , body = b , type_comment = tc , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        _async = self.expect_type(58)
        if _async:
            literal = self.expect_type(520)
            if literal:
                literal_1 = self.expect_type(7)
                if literal_1:
                    a = self._gather_56()
                    if a:
                        opt = self.expect_type(12)
                        if True:
                            literal_2 = self.expect_type(8)
                            if literal_2:
                                literal_3 = self.expect_type(11)
                                if literal_3:
                                    b = self.block()
                                    if b:
                                        tok = self.get_last_non_whitespace_token()
                                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                                        return self . check_version ( ( 3 , 9 ) , "Parenthesized with items" , ast . AsyncWith ( items = a , body = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) )
        self._reset(mark)
        _async = self.expect_type(58)
        if _async:
            literal = self.expect_type(520)
            if literal:
                a = self._gather_58()
                if a:
                    literal_1 = self.expect_type(11)
                    if literal_1:
                        tc = self.type_comment()
                        if True:
                            b = self.block()
                            if b:
                                tok = self.get_last_non_whitespace_token()
                                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                                return self . check_version ( ( 3 , 5 ) , "Async with statements are" , ast . AsyncWith ( items = a , body = b , type_comment = tc , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) )
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_with_stmt = self.invalid_with_stmt()
            if invalid_with_stmt:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def with_item(self): # type Optional[ast . withitem]
        # with_item: expression 'as' star_target &(',' | ')' | ':') | invalid_with_item | expression
        mark = self._mark()
        e = self.expression()
        if e:
            literal = self.expect_type(521)
            if literal:
                t = self.star_target()
                if t:
                    
                    if self.positive_lookahead(self._tmp_60, ):
                        return ast . withitem ( context_expr = e , optional_vars = t )
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_with_item = self.invalid_with_item()
            if invalid_with_item:
                return None  # pragma: no cover
            self._reset(mark)
        e = self.expression()
        if e:
            return ast . withitem ( context_expr = e , optional_vars = None )
        self._reset(mark)
        return None

    @logger
    def try_stmt(self): # type Optional[ast . Try]
        # try_stmt: invalid_try_stmt | 'try' &&':' block finally_block | 'try' &&':' block except_block+ else_block? finally_block?
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        if self.call_invalid_rules:
            invalid_try_stmt = self.invalid_try_stmt()
            if invalid_try_stmt:
                return None  # pragma: no cover
            self._reset(mark)
        literal = self.expect_type(510)
        if literal:
            literal_1 = self.expect_forced(self.expect_type(11), "':'")
            if literal_1:
                b = self.block()
                if b:
                    f = self.finally_block()
                    if f:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . Try ( body = b , handlers = None , orelse = None , finalbody = f , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(510)
        if literal:
            literal_1 = self.expect_forced(self.expect_type(11), "':'")
            if literal_1:
                b = self.block()
                if b:
                    ex = self._loop1_61()
                    if ex:
                        el = self.else_block()
                        if True:
                            f = self.finally_block()
                            if True:
                                tok = self.get_last_non_whitespace_token()
                                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                                return ast . Try ( body = b , handlers = ex , orelse = el , finalbody = f , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def except_block(self): # type Optional[ast . ExceptHandler]
        # except_block: invalid_except_stmt_indent | 'except' expression ['as' NAME] ':' block | 'except' ':' block | invalid_except_stmt
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        if self.call_invalid_rules:
            invalid_except_stmt_indent = self.invalid_except_stmt_indent()
            if invalid_except_stmt_indent:
                return None  # pragma: no cover
            self._reset(mark)
        literal = self.expect_type(522)
        if literal:
            e = self.expression()
            if e:
                t = self._tmp_62()
                if True:
                    literal_1 = self.expect_type(11)
                    if literal_1:
                        b = self.block()
                        if b:
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return ast . ExceptHandler ( type = e , name = self . check_for_forbidden_assignment_target ( t ) , body = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(522)
        if literal:
            literal_1 = self.expect_type(11)
            if literal_1:
                b = self.block()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . ExceptHandler ( type = None , name = None , body = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_except_stmt = self.invalid_except_stmt()
            if invalid_except_stmt:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def finally_block(self): # type Optional[list]
        # finally_block: invalid_finally_stmt | 'finally' &&':' block
        mark = self._mark()
        if self.call_invalid_rules:
            invalid_finally_stmt = self.invalid_finally_stmt()
            if invalid_finally_stmt:
                return None  # pragma: no cover
            self._reset(mark)
        literal = self.expect_type(523)
        if literal:
            literal_1 = self.expect_forced(self.expect_type(11), "':'")
            if literal_1:
                a = self.block()
                if a:
                    return a
        self._reset(mark)
        return None

    @logger
    def match_stmt(self): # type Optional["ast.Match"]
        # match_stmt: "match" subject_expr ':' NEWLINE INDENT case_block+ DEDENT | invalid_match_stmt
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect("match")
        if literal:
            subject = self.subject_expr()
            if subject:
                literal_1 = self.expect_type(11)
                if literal_1:
                    _newline = self.expect_type(4)
                    if _newline:
                        _indent = self.expect_type(5)
                        if _indent:
                            cases = self._loop1_63()
                            if cases:
                                _dedent = self.expect_type(6)
                                if _dedent:
                                    tok = self.get_last_non_whitespace_token()
                                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                                    return ast . Match ( subject = subject , cases = cases , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_match_stmt = self.invalid_match_stmt()
            if invalid_match_stmt:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def subject_expr(self): # type Optional[Any]
        # subject_expr: star_named_expression ',' star_named_expressions? | named_expression
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        value = self.star_named_expression()
        if value:
            literal = self.expect_type(12)
            if literal:
                values = self.star_named_expressions()
                if True:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return self . check_version ( ( 3 , 10 ) , "Pattern matching is" , ast . Tuple ( elts = [value] + ( values or [] ) , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) )
        self._reset(mark)
        e = self.named_expression()
        if e:
            return self . check_version ( ( 3 , 10 ) , "Pattern matching is" , e )
        self._reset(mark)
        return None

    @logger
    def case_block(self): # type Optional["ast.match_case"]
        # case_block: invalid_case_block | "case" patterns guard? ':' block
        mark = self._mark()
        if self.call_invalid_rules:
            invalid_case_block = self.invalid_case_block()
            if invalid_case_block:
                return None  # pragma: no cover
            self._reset(mark)
        literal = self.expect("case")
        if literal:
            pattern = self.patterns()
            if pattern:
                guard = self.guard()
                if True:
                    literal_1 = self.expect_type(11)
                    if literal_1:
                        body = self.block()
                        if body:
                            return ast . match_case ( pattern = pattern , guard = guard , body = body )
        self._reset(mark)
        return None

    @logger
    def guard(self): # type Optional[Any]
        # guard: 'if' named_expression
        mark = self._mark()
        literal = self.expect_type(509)
        if literal:
            guard = self.named_expression()
            if guard:
                return guard
        self._reset(mark)
        return None

    @logger
    def patterns(self): # type Optional[Any]
        # patterns: open_sequence_pattern | pattern
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        patterns = self.open_sequence_pattern()
        if patterns:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . MatchSequence ( patterns = patterns , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        pattern = self.pattern()
        if pattern:
            return pattern
        self._reset(mark)
        return None

    @logger
    def pattern(self): # type Optional[Any]
        # pattern: as_pattern | or_pattern
        mark = self._mark()
        as_pattern = self.as_pattern()
        if as_pattern:
            return as_pattern
        self._reset(mark)
        or_pattern = self.or_pattern()
        if or_pattern:
            return or_pattern
        self._reset(mark)
        return None

    @logger
    def as_pattern(self): # type Optional["ast.MatchAs"]
        # as_pattern: or_pattern 'as' pattern_capture_target | invalid_as_pattern
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        pattern = self.or_pattern()
        if pattern:
            literal = self.expect_type(521)
            if literal:
                target = self.pattern_capture_target()
                if target:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . MatchAs ( pattern = pattern , name = target , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_as_pattern = self.invalid_as_pattern()
            if invalid_as_pattern:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def or_pattern(self): # type Optional["ast.MatchOr"]
        # or_pattern: '|'.closed_pattern+
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        patterns = self._gather_64()
        if patterns:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . MatchOr ( patterns = patterns , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) if len ( patterns ) > 1 else patterns [0]
        self._reset(mark)
        return None

    @logger
    def closed_pattern(self): # type Optional[Any]
        # closed_pattern: literal_pattern | capture_pattern | wildcard_pattern | value_pattern | group_pattern | sequence_pattern | mapping_pattern | class_pattern
        mark = self._mark()
        literal_pattern = self.literal_pattern()
        if literal_pattern:
            return literal_pattern
        self._reset(mark)
        capture_pattern = self.capture_pattern()
        if capture_pattern:
            return capture_pattern
        self._reset(mark)
        wildcard_pattern = self.wildcard_pattern()
        if wildcard_pattern:
            return wildcard_pattern
        self._reset(mark)
        value_pattern = self.value_pattern()
        if value_pattern:
            return value_pattern
        self._reset(mark)
        group_pattern = self.group_pattern()
        if group_pattern:
            return group_pattern
        self._reset(mark)
        sequence_pattern = self.sequence_pattern()
        if sequence_pattern:
            return sequence_pattern
        self._reset(mark)
        mapping_pattern = self.mapping_pattern()
        if mapping_pattern:
            return mapping_pattern
        self._reset(mark)
        class_pattern = self.class_pattern()
        if class_pattern:
            return class_pattern
        self._reset(mark)
        return None

    @logger
    def literal_pattern(self): # type Optional[Any]
        # literal_pattern: signed_number !('+' | '-') | complex_number | strings | 'None' | 'True' | 'False'
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        value = self.signed_number()
        if value:
            
            if self.negative_lookahead(self._tmp_66, ):
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . MatchValue ( value = value , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        value = self.complex_number()
        if value:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . MatchValue ( value = value , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        value = self.strings()
        if value:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . MatchValue ( value = value , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(524)
        if literal:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . MatchSingleton ( value = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(525)
        if literal:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . MatchSingleton ( value = True , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(526)
        if literal:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . MatchSingleton ( value = False , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def literal_expr(self): # type Optional[Any]
        # literal_expr: signed_number !('+' | '-') | complex_number | strings | 'None' | 'True' | 'False'
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        signed_number = self.signed_number()
        if signed_number:
            
            if self.negative_lookahead(self._tmp_67, ):
                return signed_number
        self._reset(mark)
        complex_number = self.complex_number()
        if complex_number:
            return complex_number
        self._reset(mark)
        strings = self.strings()
        if strings:
            return strings
        self._reset(mark)
        literal = self.expect_type(524)
        if literal:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . Constant ( value = self . space . w_None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(525)
        if literal:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . Constant ( value = self . space . w_True , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(526)
        if literal:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . Constant ( value = self . space . w_False , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def complex_number(self): # type Optional[Any]
        # complex_number: signed_real_number '+' imaginary_number | signed_real_number '-' imaginary_number
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        real = self.signed_real_number()
        if real:
            literal = self.expect_type(14)
            if literal:
                imag = self.imaginary_number()
                if imag:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . BinOp ( left = real , op = ast . Add , right = imag , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        real = self.signed_real_number()
        if real:
            literal = self.expect_type(15)
            if literal:
                imag = self.imaginary_number()
                if imag:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . BinOp ( left = real , op = ast . Sub , right = imag , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def signed_number(self): # type Optional[Any]
        # signed_number: NUMBER | '-' NUMBER
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.number()
        if a:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . Constant ( value = parse_number ( self . space , a . value ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(15)
        if literal:
            a = self.number()
            if a:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . UnaryOp ( op = ast . USub ( ) , operand = ast . Constant ( value = ast . parse_number ( self . space , a . value ) , lineno = a . lineno , col_offset = a . column , end_lineno = a . end_lineno , end_col_offset = a . end_column ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , )
        self._reset(mark)
        return None

    @logger
    def signed_real_number(self): # type Optional[Any]
        # signed_real_number: real_number | '-' real_number
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        real_number = self.real_number()
        if real_number:
            return real_number
        self._reset(mark)
        literal = self.expect_type(15)
        if literal:
            real = self.real_number()
            if real:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . UnaryOp ( op = ast . USub ( ) , operand = real , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def real_number(self): # type Optional[ast . Constant]
        # real_number: NUMBER
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        real = self.number()
        if real:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . Constant ( value = self . ensure_real ( real . value ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def imaginary_number(self): # type Optional[ast . Constant]
        # imaginary_number: NUMBER
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        imag = self.number()
        if imag:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . Constant ( value = self . ensure_imaginary ( imag . value ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def capture_pattern(self): # type Optional[Any]
        # capture_pattern: pattern_capture_target
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        target = self.pattern_capture_target()
        if target:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . MatchAs ( pattern = None , name = target , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def pattern_capture_target(self): # type Optional[str]
        # pattern_capture_target: !"_" NAME !('.' | '(' | '=')
        mark = self._mark()
        
        if self.negative_lookahead(self.expect, "_"):
            name = self.name()
            if name:
                
                if self.negative_lookahead(self._tmp_68, ):
                    return name . id
        self._reset(mark)
        return None

    @logger
    def wildcard_pattern(self): # type Optional["ast.MatchAs"]
        # wildcard_pattern: "_"
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect("_")
        if literal:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . MatchAs ( pattern = None , target = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def value_pattern(self): # type Optional["ast.MatchValue"]
        # value_pattern: attr !('.' | '(' | '=')
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        attr = self.attr()
        if attr:
            
            if self.negative_lookahead(self._tmp_69, ):
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . MatchValue ( value = attr , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @memoize_left_rec
    def attr(self): # type Optional[ast . Attribute]
        # attr: name_or_attr '.' NAME
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        value = self.name_or_attr()
        if value:
            literal = self.expect_type(23)
            if literal:
                attr = self.name()
                if attr:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . Attribute ( value = value , attr = attr . id , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def name_or_attr(self): # type Optional[Any]
        # name_or_attr: attr | NAME
        mark = self._mark()
        attr = self.attr()
        if attr:
            return attr
        self._reset(mark)
        name = self.name()
        if name:
            return name
        self._reset(mark)
        return None

    @logger
    def group_pattern(self): # type Optional[Any]
        # group_pattern: '(' pattern ')'
        mark = self._mark()
        literal = self.expect_type(7)
        if literal:
            pattern = self.pattern()
            if pattern:
                literal_1 = self.expect_type(8)
                if literal_1:
                    return pattern
        self._reset(mark)
        return None

    @logger
    def sequence_pattern(self): # type Optional["ast.MatchSequence"]
        # sequence_pattern: '[' maybe_sequence_pattern? ']' | '(' open_sequence_pattern? ')'
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(9)
        if literal:
            patterns = self.maybe_sequence_pattern()
            if True:
                literal_1 = self.expect_type(10)
                if literal_1:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . MatchSequence ( patterns = patterns , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(7)
        if literal:
            patterns = self.open_sequence_pattern()
            if True:
                literal_1 = self.expect_type(8)
                if literal_1:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . MatchSequence ( patterns = patterns , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def open_sequence_pattern(self): # type Optional[Any]
        # open_sequence_pattern: maybe_star_pattern ',' maybe_sequence_pattern?
        mark = self._mark()
        pattern = self.maybe_star_pattern()
        if pattern:
            literal = self.expect_type(12)
            if literal:
                patterns = self.maybe_sequence_pattern()
                if True:
                    return [pattern] + ( patterns or [] )
        self._reset(mark)
        return None

    @logger
    def maybe_sequence_pattern(self): # type Optional[Any]
        # maybe_sequence_pattern: ','.maybe_star_pattern+ ','?
        mark = self._mark()
        patterns = self._gather_70()
        if patterns:
            opt = self.expect_type(12)
            if True:
                return patterns
        self._reset(mark)
        return None

    @logger
    def maybe_star_pattern(self): # type Optional[Any]
        # maybe_star_pattern: star_pattern | pattern
        mark = self._mark()
        star_pattern = self.star_pattern()
        if star_pattern:
            return star_pattern
        self._reset(mark)
        pattern = self.pattern()
        if pattern:
            return pattern
        self._reset(mark)
        return None

    @logger
    def star_pattern(self): # type Optional[Any]
        # star_pattern: '*' pattern_capture_target | '*' wildcard_pattern
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(16)
        if literal:
            target = self.pattern_capture_target()
            if target:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . MatchStar ( name = target , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(16)
        if literal:
            wildcard_pattern = self.wildcard_pattern()
            if wildcard_pattern:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . MatchStar ( target = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def mapping_pattern(self): # type Optional[Any]
        # mapping_pattern: '{' '}' | '{' double_star_pattern ','? '}' | '{' items_pattern ',' double_star_pattern ','? '}' | '{' items_pattern ','? '}'
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(26)
        if literal:
            literal_1 = self.expect_type(27)
            if literal_1:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . MatchMapping ( keys = None , patterns = None , rest = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(26)
        if literal:
            rest = self.double_star_pattern()
            if rest:
                opt = self.expect_type(12)
                if True:
                    literal_1 = self.expect_type(27)
                    if literal_1:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . MatchMapping ( keys = None , patterns = None , rest = rest , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(26)
        if literal:
            items = self.items_pattern()
            if items:
                literal_1 = self.expect_type(12)
                if literal_1:
                    rest = self.double_star_pattern()
                    if rest:
                        opt = self.expect_type(12)
                        if True:
                            literal_2 = self.expect_type(27)
                            if literal_2:
                                tok = self.get_last_non_whitespace_token()
                                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                                return ast . MatchMapping ( keys = [k for k , _ in items] , patterns = [p for _ , p in items] , rest = rest , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , )
        self._reset(mark)
        literal = self.expect_type(26)
        if literal:
            items = self.items_pattern()
            if items:
                opt = self.expect_type(12)
                if True:
                    literal_1 = self.expect_type(27)
                    if literal_1:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . MatchMapping ( keys = [k for k , _ in items] , patterns = [p for _ , p in items] , rest = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , )
        self._reset(mark)
        return None

    @logger
    def items_pattern(self): # type Optional[Any]
        # items_pattern: ','.key_value_pattern+
        mark = self._mark()
        _gather_72 = self._gather_72()
        if _gather_72:
            return _gather_72
        self._reset(mark)
        return None

    @logger
    def key_value_pattern(self): # type Optional[Any]
        # key_value_pattern: (literal_expr | attr) ':' pattern
        mark = self._mark()
        key = self._tmp_74()
        if key:
            literal = self.expect_type(11)
            if literal:
                pattern = self.pattern()
                if pattern:
                    return ( key , pattern )
        self._reset(mark)
        return None

    @logger
    def double_star_pattern(self): # type Optional[Any]
        # double_star_pattern: '**' pattern_capture_target
        mark = self._mark()
        literal = self.expect_type(36)
        if literal:
            target = self.pattern_capture_target()
            if target:
                return target
        self._reset(mark)
        return None

    @logger
    def class_pattern(self): # type Optional["ast.MatchClass"]
        # class_pattern: name_or_attr '(' ')' | name_or_attr '(' positional_patterns ','? ')' | name_or_attr '(' keyword_patterns ','? ')' | name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')' | invalid_class_pattern
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        cls = self.name_or_attr()
        if cls:
            literal = self.expect_type(7)
            if literal:
                literal_1 = self.expect_type(8)
                if literal_1:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . MatchClass ( cls = cls , patterns = None , kwd_attrs = None , kwd_patterns = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        cls = self.name_or_attr()
        if cls:
            literal = self.expect_type(7)
            if literal:
                patterns = self.positional_patterns()
                if patterns:
                    opt = self.expect_type(12)
                    if True:
                        literal_1 = self.expect_type(8)
                        if literal_1:
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return ast . MatchClass ( cls = cls , patterns = patterns , kwd_attrs = None , kwd_patterns = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        cls = self.name_or_attr()
        if cls:
            literal = self.expect_type(7)
            if literal:
                keywords = self.keyword_patterns()
                if keywords:
                    opt = self.expect_type(12)
                    if True:
                        literal_1 = self.expect_type(8)
                        if literal_1:
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return ast . MatchClass ( cls = cls , patterns = None , kwd_attrs = [k for k , _ in keywords] , kwd_patterns = [p for _ , p in keywords] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , )
        self._reset(mark)
        cls = self.name_or_attr()
        if cls:
            literal = self.expect_type(7)
            if literal:
                patterns = self.positional_patterns()
                if patterns:
                    literal_1 = self.expect_type(12)
                    if literal_1:
                        keywords = self.keyword_patterns()
                        if keywords:
                            opt = self.expect_type(12)
                            if True:
                                literal_2 = self.expect_type(8)
                                if literal_2:
                                    tok = self.get_last_non_whitespace_token()
                                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                                    return ast . MatchClass ( cls = cls , patterns = patterns , kwd_attrs = [k for k , _ in keywords] , kwd_patterns = [p for _ , p in keywords] , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , )
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_class_pattern = self.invalid_class_pattern()
            if invalid_class_pattern:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def positional_patterns(self): # type Optional[Any]
        # positional_patterns: ','.pattern+
        mark = self._mark()
        args = self._gather_75()
        if args:
            return args
        self._reset(mark)
        return None

    @logger
    def keyword_patterns(self): # type Optional[Any]
        # keyword_patterns: ','.keyword_pattern+
        mark = self._mark()
        _gather_77 = self._gather_77()
        if _gather_77:
            return _gather_77
        self._reset(mark)
        return None

    @logger
    def keyword_pattern(self): # type Optional[Any]
        # keyword_pattern: NAME '=' pattern
        mark = self._mark()
        arg = self.name()
        if arg:
            literal = self.expect_type(22)
            if literal:
                value = self.pattern()
                if value:
                    return ( arg . id , value )
        self._reset(mark)
        return None

    @logger
    def expressions(self): # type Optional[Any]
        # expressions: expression ((',' expression))+ ','? | expression ',' | expression
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.expression()
        if a:
            b = self._loop1_79()
            if b:
                opt = self.expect_type(12)
                if True:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . Tuple ( elts = [a] + b , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.expression()
        if a:
            literal = self.expect_type(12)
            if literal:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . Tuple ( elts = [a] , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        expression = self.expression()
        if expression:
            return expression
        self._reset(mark)
        return None

    @memoize
    def expression(self): # type Optional[Any]
        # expression: invalid_expression | disjunction 'if' disjunction 'else' expression | disjunction | lambdef
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        if self.call_invalid_rules:
            invalid_expression = self.invalid_expression()
            if invalid_expression:
                return None  # pragma: no cover
            self._reset(mark)
        a = self.disjunction()
        if a:
            literal = self.expect_type(509)
            if literal:
                b = self.disjunction()
                if b:
                    literal_1 = self.expect_type(517)
                    if literal_1:
                        c = self.expression()
                        if c:
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return ast . IfExp ( body = a , test = b , orelse = c , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        disjunction = self.disjunction()
        if disjunction:
            return disjunction
        self._reset(mark)
        lambdef = self.lambdef()
        if lambdef:
            return lambdef
        self._reset(mark)
        return None

    @logger
    def yield_expr(self): # type Optional[Any]
        # yield_expr: 'yield' 'from' expression | 'yield' star_expressions?
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(503)
        if literal:
            literal_1 = self.expect_type(513)
            if literal_1:
                a = self.expression()
                if a:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . YieldFrom ( value = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(503)
        if literal:
            a = self.star_expressions()
            if True:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . Yield ( value = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def star_expressions(self): # type Optional[Any]
        # star_expressions: star_expression ((',' star_expression))+ ','? | star_expression ',' | star_expression
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.star_expression()
        if a:
            b = self._loop1_80()
            if b:
                opt = self.expect_type(12)
                if True:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . Tuple ( elts = [a] + b , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.star_expression()
        if a:
            literal = self.expect_type(12)
            if literal:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . Tuple ( elts = [a] , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        star_expression = self.star_expression()
        if star_expression:
            return star_expression
        self._reset(mark)
        return None

    @memoize
    def star_expression(self): # type Optional[Any]
        # star_expression: '*' bitwise_or | expression
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(16)
        if literal:
            a = self.bitwise_or()
            if a:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . Starred ( value = a , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        expression = self.expression()
        if expression:
            return expression
        self._reset(mark)
        return None

    @logger
    def star_named_expressions(self): # type Optional[Any]
        # star_named_expressions: ','.star_named_expression+ ','?
        mark = self._mark()
        a = self._gather_81()
        if a:
            opt = self.expect_type(12)
            if True:
                return a
        self._reset(mark)
        return None

    @logger
    def star_named_expression(self): # type Optional[Any]
        # star_named_expression: '*' bitwise_or | named_expression
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(16)
        if literal:
            a = self.bitwise_or()
            if a:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . Starred ( value = a , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        named_expression = self.named_expression()
        if named_expression:
            return named_expression
        self._reset(mark)
        return None

    @logger
    def assignment_expression(self): # type Optional[Any]
        # assignment_expression: NAME ':=' ~ expression
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        cut = False
        a = self.name()
        if a:
            literal = self.expect_type(54)
            if literal:
                cut = True
                if cut:
                    b = self.expression()
                    if b:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return self . check_version ( ( 3 , 8 ) , "The ':=' operator is" , ast . NamedExpr ( target = self . set_expr_context ( a , Store ) , value = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , ) )
        self._reset(mark)
        if cut: return None
        return None

    @logger
    def named_expression(self): # type Optional[Any]
        # named_expression: assignment_expression | invalid_named_expression | expression !':='
        mark = self._mark()
        assignment_expression = self.assignment_expression()
        if assignment_expression:
            return assignment_expression
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_named_expression = self.invalid_named_expression()
            if invalid_named_expression:
                return None  # pragma: no cover
            self._reset(mark)
        a = self.expression()
        if a:
            
            if self.negative_lookahead(self.expect_type, 54):
                return a
        self._reset(mark)
        return None

    @memoize
    def disjunction(self): # type Optional[Any]
        # disjunction: conjunction (('or' conjunction))+ | conjunction
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.conjunction()
        if a:
            b = self._loop1_83()
            if b:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . BoolOp ( op = ast . Or , values = [a] + b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        conjunction = self.conjunction()
        if conjunction:
            return conjunction
        self._reset(mark)
        return None

    @memoize
    def conjunction(self): # type Optional[Any]
        # conjunction: inversion (('and' inversion))+ | inversion
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.inversion()
        if a:
            b = self._loop1_84()
            if b:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . BoolOp ( op = ast . And , values = [a] + b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        inversion = self.inversion()
        if inversion:
            return inversion
        self._reset(mark)
        return None

    @memoize
    def inversion(self): # type Optional[Any]
        # inversion: 'not' inversion | comparison
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(527)
        if literal:
            a = self.inversion()
            if a:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . UnaryOp ( op = ast . Not , operand = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        comparison = self.comparison()
        if comparison:
            return comparison
        self._reset(mark)
        return None

    @logger
    def comparison(self): # type Optional[Any]
        # comparison: bitwise_or compare_op_bitwise_or_pair+ | bitwise_or
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.bitwise_or()
        if a:
            b = self._loop1_85()
            if b:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . Compare ( left = a , ops = self . get_comparison_ops ( b ) , comparators = self . get_comparators ( b ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        bitwise_or = self.bitwise_or()
        if bitwise_or:
            return bitwise_or
        self._reset(mark)
        return None

    @logger
    def compare_op_bitwise_or_pair(self): # type Optional[Any]
        # compare_op_bitwise_or_pair: eq_bitwise_or | noteq_bitwise_or | lte_bitwise_or | lt_bitwise_or | gte_bitwise_or | gt_bitwise_or | notin_bitwise_or | in_bitwise_or | isnot_bitwise_or | is_bitwise_or
        mark = self._mark()
        eq_bitwise_or = self.eq_bitwise_or()
        if eq_bitwise_or:
            return eq_bitwise_or
        self._reset(mark)
        noteq_bitwise_or = self.noteq_bitwise_or()
        if noteq_bitwise_or:
            return noteq_bitwise_or
        self._reset(mark)
        lte_bitwise_or = self.lte_bitwise_or()
        if lte_bitwise_or:
            return lte_bitwise_or
        self._reset(mark)
        lt_bitwise_or = self.lt_bitwise_or()
        if lt_bitwise_or:
            return lt_bitwise_or
        self._reset(mark)
        gte_bitwise_or = self.gte_bitwise_or()
        if gte_bitwise_or:
            return gte_bitwise_or
        self._reset(mark)
        gt_bitwise_or = self.gt_bitwise_or()
        if gt_bitwise_or:
            return gt_bitwise_or
        self._reset(mark)
        notin_bitwise_or = self.notin_bitwise_or()
        if notin_bitwise_or:
            return notin_bitwise_or
        self._reset(mark)
        in_bitwise_or = self.in_bitwise_or()
        if in_bitwise_or:
            return in_bitwise_or
        self._reset(mark)
        isnot_bitwise_or = self.isnot_bitwise_or()
        if isnot_bitwise_or:
            return isnot_bitwise_or
        self._reset(mark)
        is_bitwise_or = self.is_bitwise_or()
        if is_bitwise_or:
            return is_bitwise_or
        self._reset(mark)
        return None

    @logger
    def eq_bitwise_or(self): # type Optional[Any]
        # eq_bitwise_or: '==' bitwise_or
        mark = self._mark()
        literal = self.expect_type(28)
        if literal:
            a = self.bitwise_or()
            if a:
                return ( ast . Eq , a )
        self._reset(mark)
        return None

    @logger
    def noteq_bitwise_or(self): # type Optional[tuple]
        # noteq_bitwise_or: '!=' bitwise_or
        mark = self._mark()
        tok = self.expect_type(29)
        if tok:
            a = self.bitwise_or()
            if a:
                return self . check_barry ( tok ) and ( ast . NotEq , a )
        self._reset(mark)
        return None

    @logger
    def lte_bitwise_or(self): # type Optional[Any]
        # lte_bitwise_or: '<=' bitwise_or
        mark = self._mark()
        literal = self.expect_type(30)
        if literal:
            a = self.bitwise_or()
            if a:
                return ( ast . LtE , a )
        self._reset(mark)
        return None

    @logger
    def lt_bitwise_or(self): # type Optional[Any]
        # lt_bitwise_or: '<' bitwise_or
        mark = self._mark()
        literal = self.expect_type(20)
        if literal:
            a = self.bitwise_or()
            if a:
                return ( ast . Lt , a )
        self._reset(mark)
        return None

    @logger
    def gte_bitwise_or(self): # type Optional[Any]
        # gte_bitwise_or: '>=' bitwise_or
        mark = self._mark()
        literal = self.expect_type(31)
        if literal:
            a = self.bitwise_or()
            if a:
                return ( ast . GtE , a )
        self._reset(mark)
        return None

    @logger
    def gt_bitwise_or(self): # type Optional[Any]
        # gt_bitwise_or: '>' bitwise_or
        mark = self._mark()
        literal = self.expect_type(21)
        if literal:
            a = self.bitwise_or()
            if a:
                return ( ast . Gt , a )
        self._reset(mark)
        return None

    @logger
    def notin_bitwise_or(self): # type Optional[Any]
        # notin_bitwise_or: 'not' 'in' bitwise_or
        mark = self._mark()
        literal = self.expect_type(527)
        if literal:
            literal_1 = self.expect_type(519)
            if literal_1:
                a = self.bitwise_or()
                if a:
                    return ( ast . NotIn , a )
        self._reset(mark)
        return None

    @logger
    def in_bitwise_or(self): # type Optional[Any]
        # in_bitwise_or: 'in' bitwise_or
        mark = self._mark()
        literal = self.expect_type(519)
        if literal:
            a = self.bitwise_or()
            if a:
                return ( ast . In , a )
        self._reset(mark)
        return None

    @logger
    def isnot_bitwise_or(self): # type Optional[Any]
        # isnot_bitwise_or: 'is' 'not' bitwise_or
        mark = self._mark()
        literal = self.expect_type(528)
        if literal:
            literal_1 = self.expect_type(527)
            if literal_1:
                a = self.bitwise_or()
                if a:
                    return ( ast . IsNot , a )
        self._reset(mark)
        return None

    @logger
    def is_bitwise_or(self): # type Optional[Any]
        # is_bitwise_or: 'is' bitwise_or
        mark = self._mark()
        literal = self.expect_type(528)
        if literal:
            a = self.bitwise_or()
            if a:
                return ( ast . Is , a )
        self._reset(mark)
        return None

    @memoize_left_rec
    def bitwise_or(self): # type Optional[Any]
        # bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.bitwise_or()
        if a:
            literal = self.expect_type(18)
            if literal:
                b = self.bitwise_xor()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . BinOp ( left = a , op = ast . BitOr , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        bitwise_xor = self.bitwise_xor()
        if bitwise_xor:
            return bitwise_xor
        self._reset(mark)
        return None

    @memoize_left_rec
    def bitwise_xor(self): # type Optional[Any]
        # bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.bitwise_xor()
        if a:
            literal = self.expect_type(33)
            if literal:
                b = self.bitwise_and()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . BinOp ( left = a , op = ast . BitXor , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        bitwise_and = self.bitwise_and()
        if bitwise_and:
            return bitwise_and
        self._reset(mark)
        return None

    @memoize_left_rec
    def bitwise_and(self): # type Optional[Any]
        # bitwise_and: bitwise_and '&' shift_expr | shift_expr
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.bitwise_and()
        if a:
            literal = self.expect_type(19)
            if literal:
                b = self.shift_expr()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . BinOp ( left = a , op = ast . BitAnd , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        shift_expr = self.shift_expr()
        if shift_expr:
            return shift_expr
        self._reset(mark)
        return None

    @memoize_left_rec
    def shift_expr(self): # type Optional[Any]
        # shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.shift_expr()
        if a:
            literal = self.expect_type(34)
            if literal:
                b = self.sum()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . BinOp ( left = a , op = ast . LShift , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.shift_expr()
        if a:
            literal = self.expect_type(35)
            if literal:
                b = self.sum()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . BinOp ( left = a , op = ast . RShift , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        sum = self.sum()
        if sum:
            return sum
        self._reset(mark)
        return None

    @memoize_left_rec
    def sum(self): # type Optional[Any]
        # sum: sum '+' term | sum '-' term | term
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.sum()
        if a:
            literal = self.expect_type(14)
            if literal:
                b = self.term()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . BinOp ( left = a , op = ast . Add , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.sum()
        if a:
            literal = self.expect_type(15)
            if literal:
                b = self.term()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . BinOp ( left = a , op = ast . Sub , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        term = self.term()
        if term:
            return term
        self._reset(mark)
        return None

    @memoize_left_rec
    def term(self): # type Optional[Any]
        # term: term '*' factor | term '/' factor | term '//' factor | term '%' factor | term '@' factor | factor
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.term()
        if a:
            literal = self.expect_type(16)
            if literal:
                b = self.factor()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . BinOp ( left = a , op = ast . Mult , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.term()
        if a:
            literal = self.expect_type(17)
            if literal:
                b = self.factor()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . BinOp ( left = a , op = ast . Div , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.term()
        if a:
            literal = self.expect_type(48)
            if literal:
                b = self.factor()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . BinOp ( left = a , op = ast . FloorDiv , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.term()
        if a:
            literal = self.expect_type(24)
            if literal:
                b = self.factor()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . BinOp ( left = a , op = ast . Mod , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.term()
        if a:
            literal = self.expect_type(50)
            if literal:
                b = self.factor()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return self . check_version ( ( 3 , 5 ) , "The '@' operator is" , ast . BinOp ( left = a , op = ast . MatMult , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) )
        self._reset(mark)
        factor = self.factor()
        if factor:
            return factor
        self._reset(mark)
        return None

    @memoize
    def factor(self): # type Optional[Any]
        # factor: '+' factor | '-' factor | '~' factor | power
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(14)
        if literal:
            a = self.factor()
            if a:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . UnaryOp ( op = ast . UAdd , operand = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(15)
        if literal:
            a = self.factor()
            if a:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . UnaryOp ( op = ast . USub , operand = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(32)
        if literal:
            a = self.factor()
            if a:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . UnaryOp ( op = ast . Invert , operand = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        power = self.power()
        if power:
            return power
        self._reset(mark)
        return None

    @logger
    def power(self): # type Optional[Any]
        # power: await_primary '**' factor | await_primary
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.await_primary()
        if a:
            literal = self.expect_type(36)
            if literal:
                b = self.factor()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . BinOp ( left = a , op = ast . Pow , right = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        await_primary = self.await_primary()
        if await_primary:
            return await_primary
        self._reset(mark)
        return None

    @memoize
    def await_primary(self): # type Optional[Any]
        # await_primary: AWAIT primary | primary
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        _await = self.expect_type(59)
        if _await:
            a = self.primary()
            if a:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return self . check_version ( ( 3 , 5 ) , "Await expressions are" , ast . Await ( a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) )
        self._reset(mark)
        primary = self.primary()
        if primary:
            return primary
        self._reset(mark)
        return None

    @memoize_left_rec
    def primary(self): # type Optional[Any]
        # primary: primary '.' NAME | primary genexp | primary '(' arguments? ')' | primary '[' slices ']' | atom
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.primary()
        if a:
            literal = self.expect_type(23)
            if literal:
                b = self.name()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . Attribute ( value = a , attr = b . id , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.primary()
        if a:
            b = self.genexp()
            if b:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . Call ( func = a , args = [b] , keywords = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.primary()
        if a:
            literal = self.expect_type(7)
            if literal:
                b = self.arguments()
                if True:
                    literal_1 = self.expect_type(8)
                    if literal_1:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . Call ( func = a , args = b [0] if b and b [0] else None , keywords = self . check_repeated_keywords ( b ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , )
        self._reset(mark)
        a = self.primary()
        if a:
            literal = self.expect_type(9)
            if literal:
                b = self.slices()
                if b:
                    literal_1 = self.expect_type(10)
                    if literal_1:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . Subscript ( value = a , slice = b , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        atom = self.atom()
        if atom:
            return atom
        self._reset(mark)
        return None

    @logger
    def slices(self): # type Optional[Any]
        # slices: slice !',' | ','.slice+ ','?
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.slice()
        if a:
            
            if self.negative_lookahead(self.expect_type, 12):
                return a
        self._reset(mark)
        a = self._gather_86()
        if a:
            opt = self.expect_type(12)
            if True:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . Tuple ( elts = a , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) if self . py_version >= ( 3 , 9 ) else ( ast . ExtSlice ( dims = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) if any ( isinstance ( e , ast . Slice ) for e in a ) else ast . Index ( value = ast . Tuple ( elts = [e . value for e in a] , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset ) )
        self._reset(mark)
        return None

    @logger
    def slice(self): # type Optional[Any]
        # slice: expression? ':' expression? [':' expression?] | named_expression
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.expression()
        if True:
            literal = self.expect_type(11)
            if literal:
                b = self.expression()
                if True:
                    c = self._tmp_88()
                    if True:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . Slice ( lower = a , upper = b , step = c , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.named_expression()
        if a:
            return a if self . py_version >= ( 3 , 9 ) or isinstance ( a , ast . Slice ) else ast . Index ( value = a , lineno = a . lineno , col_offset = a . col_offset , end_lineno = a . end_lineno , end_col_offset = a . end_col_offset )
        self._reset(mark)
        return None

    @logger
    def atom(self): # type Optional[Any]
        # atom: NAME | 'True' | 'False' | 'None' | &STRING strings | NUMBER | &'(' (tuple | group | genexp) | &'[' (list | listcomp) | &'{' (dict | set | dictcomp | setcomp) | '...'
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        name = self.name()
        if name:
            return name
        self._reset(mark)
        literal = self.expect_type(525)
        if literal:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . Constant ( value = self . space . w_True , kind = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(526)
        if literal:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . Constant ( value = self . space . w_False , kind = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(524)
        if literal:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . Constant ( value = self . space . w_None , kind = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        
        if self.positive_lookahead(self.string, ):
            strings = self.strings()
            if strings:
                return strings
        self._reset(mark)
        a = self.number()
        if a:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . Constant ( value = parse_number ( self . space , a . value ) , kind = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        
        if self.positive_lookahead(self.expect_type, 7):
            _tmp_89 = self._tmp_89()
            if _tmp_89:
                return _tmp_89
        self._reset(mark)
        
        if self.positive_lookahead(self.expect_type, 9):
            _tmp_90 = self._tmp_90()
            if _tmp_90:
                return _tmp_90
        self._reset(mark)
        
        if self.positive_lookahead(self.expect_type, 26):
            _tmp_91 = self._tmp_91()
            if _tmp_91:
                return _tmp_91
        self._reset(mark)
        literal = self.expect_type(53)
        if literal:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . Constant ( value = self . space . w_Ellipsis , kind = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def group(self): # type Optional[Any]
        # group: '(' (yield_expr | named_expression) ')' | invalid_group
        mark = self._mark()
        literal = self.expect_type(7)
        if literal:
            a = self._tmp_92()
            if a:
                literal_1 = self.expect_type(8)
                if literal_1:
                    return a
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_group = self.invalid_group()
            if invalid_group:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def lambdef(self): # type Optional[Any]
        # lambdef: 'lambda' lambda_params? ':' expression
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(529)
        if literal:
            a = self.lambda_params()
            if True:
                literal_1 = self.expect_type(11)
                if literal_1:
                    b = self.expression()
                    if b:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . Lambda ( args = a or self . make_arguments ( None , [] , None , [] , ( None , [] , None ) ) , body = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def lambda_params(self): # type Optional[Any]
        # lambda_params: invalid_lambda_parameters | lambda_parameters
        mark = self._mark()
        if self.call_invalid_rules:
            invalid_lambda_parameters = self.invalid_lambda_parameters()
            if invalid_lambda_parameters:
                return None  # pragma: no cover
            self._reset(mark)
        lambda_parameters = self.lambda_parameters()
        if lambda_parameters:
            return lambda_parameters
        self._reset(mark)
        return None

    @logger
    def lambda_parameters(self): # type Optional[ast . arguments]
        # lambda_parameters: lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc? | lambda_slash_with_default lambda_param_with_default* lambda_star_etc? | lambda_param_no_default+ lambda_param_with_default* lambda_star_etc? | lambda_param_with_default+ lambda_star_etc? | lambda_star_etc
        mark = self._mark()
        a = self.lambda_slash_no_default()
        if a:
            b = self._loop0_93()
            if True:
                c = self._loop0_94()
                if True:
                    d = self.lambda_star_etc()
                    if True:
                        return self . make_arguments ( a , [] , b , c , d )
        self._reset(mark)
        a = self.lambda_slash_with_default()
        if a:
            b = self._loop0_95()
            if True:
                c = self.lambda_star_etc()
                if True:
                    return self . make_arguments ( None , a , None , b , c )
        self._reset(mark)
        a = self._loop1_96()
        if a:
            b = self._loop0_97()
            if True:
                c = self.lambda_star_etc()
                if True:
                    return self . make_arguments ( None , [] , a , b , c )
        self._reset(mark)
        a = self._loop1_98()
        if a:
            b = self.lambda_star_etc()
            if True:
                return self . make_arguments ( None , [] , None , a , b )
        self._reset(mark)
        a = self.lambda_star_etc()
        if a:
            return self . make_arguments ( None , [] , None , [] , a )
        self._reset(mark)
        return None

    @logger
    def lambda_slash_no_default(self): # type Optional[List [Tuple [ast . arg , None]]]
        # lambda_slash_no_default: lambda_param_no_default+ '/' ',' | lambda_param_no_default+ '/' &':'
        mark = self._mark()
        a = self._loop1_99()
        if a:
            literal = self.expect_type(17)
            if literal:
                literal_1 = self.expect_type(12)
                if literal_1:
                    return [( p , None ) for p in a]
        self._reset(mark)
        a = self._loop1_100()
        if a:
            literal = self.expect_type(17)
            if literal:
                
                if self.positive_lookahead(self.expect_type, 11):
                    return [( p , None ) for p in a]
        self._reset(mark)
        return None

    @logger
    def lambda_slash_with_default(self): # type Optional[List [Tuple [ast . arg , Any]]]
        # lambda_slash_with_default: lambda_param_no_default* lambda_param_with_default+ '/' ',' | lambda_param_no_default* lambda_param_with_default+ '/' &':'
        mark = self._mark()
        a = self._loop0_101()
        if True:
            b = self._loop1_102()
            if b:
                literal = self.expect_type(17)
                if literal:
                    literal_1 = self.expect_type(12)
                    if literal_1:
                        return ( [( p , None ) for p in a] if a else [] ) + b
        self._reset(mark)
        a = self._loop0_103()
        if True:
            b = self._loop1_104()
            if b:
                literal = self.expect_type(17)
                if literal:
                    
                    if self.positive_lookahead(self.expect_type, 11):
                        return ( [( p , None ) for p in a] if a else [] ) + b
        self._reset(mark)
        return None

    @logger
    def lambda_star_etc(self): # type Optional[Tuple [Optional [ast . arg] , List [Tuple [ast . arg , Any]] , Optional [ast . arg]]]
        # lambda_star_etc: '*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds? | '*' ',' lambda_param_maybe_default+ lambda_kwds? | lambda_kwds | invalid_lambda_star_etc
        mark = self._mark()
        literal = self.expect_type(16)
        if literal:
            a = self.lambda_param_no_default()
            if a:
                b = self._loop0_105()
                if True:
                    c = self.lambda_kwds()
                    if True:
                        return ( a , b , c )
        self._reset(mark)
        literal = self.expect_type(16)
        if literal:
            literal_1 = self.expect_type(12)
            if literal_1:
                b = self._loop1_106()
                if b:
                    c = self.lambda_kwds()
                    if True:
                        return ( None , b , c )
        self._reset(mark)
        a = self.lambda_kwds()
        if a:
            return ( None , [] , a )
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_lambda_star_etc = self.invalid_lambda_star_etc()
            if invalid_lambda_star_etc:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def lambda_kwds(self): # type Optional[ast . arg]
        # lambda_kwds: '**' lambda_param_no_default
        mark = self._mark()
        literal = self.expect_type(36)
        if literal:
            a = self.lambda_param_no_default()
            if a:
                return a
        self._reset(mark)
        return None

    @logger
    def lambda_param_no_default(self): # type Optional[ast . arg]
        # lambda_param_no_default: lambda_param ',' | lambda_param &':'
        mark = self._mark()
        a = self.lambda_param()
        if a:
            literal = self.expect_type(12)
            if literal:
                return a
        self._reset(mark)
        a = self.lambda_param()
        if a:
            
            if self.positive_lookahead(self.expect_type, 11):
                return a
        self._reset(mark)
        return None

    @logger
    def lambda_param_with_default(self): # type Optional[Tuple [ast . arg , Any]]
        # lambda_param_with_default: lambda_param default ',' | lambda_param default &':'
        mark = self._mark()
        a = self.lambda_param()
        if a:
            c = self.default()
            if c:
                literal = self.expect_type(12)
                if literal:
                    return ( a , c )
        self._reset(mark)
        a = self.lambda_param()
        if a:
            c = self.default()
            if c:
                
                if self.positive_lookahead(self.expect_type, 11):
                    return ( a , c )
        self._reset(mark)
        return None

    @logger
    def lambda_param_maybe_default(self): # type Optional[Tuple [ast . arg , Any]]
        # lambda_param_maybe_default: lambda_param default? ',' | lambda_param default? &':'
        mark = self._mark()
        a = self.lambda_param()
        if a:
            c = self.default()
            if True:
                literal = self.expect_type(12)
                if literal:
                    return ( a , c )
        self._reset(mark)
        a = self.lambda_param()
        if a:
            c = self.default()
            if True:
                
                if self.positive_lookahead(self.expect_type, 11):
                    return ( a , c )
        self._reset(mark)
        return None

    @logger
    def lambda_param(self): # type Optional[ast . arg]
        # lambda_param: NAME
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.name()
        if a:
            tok = self.get_last_non_whitespace_token()
            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
            return ast . arg ( arg = self . check_for_forbidden_assignment_target ( a ) , annotation = None , type_comment = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @memoize
    def strings(self): # type Optional[ast . Str]
        # strings: STRING+
        mark = self._mark()
        a = self._loop1_107()
        if a:
            return self . generate_ast_for_string ( a )
        self._reset(mark)
        return None

    @logger
    def list(self): # type Optional[ast . List]
        # list: '[' star_named_expressions? ']'
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(9)
        if literal:
            a = self.star_named_expressions()
            if True:
                literal_1 = self.expect_type(10)
                if literal_1:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . List ( elts = a , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def tuple(self): # type Optional[ast . Tuple]
        # tuple: '(' [star_named_expression ',' star_named_expressions?] ')'
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(7)
        if literal:
            a = self._tmp_108()
            if True:
                literal_1 = self.expect_type(8)
                if literal_1:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . Tuple ( elts = a , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def set(self): # type Optional[ast . Set]
        # set: '{' star_named_expressions '}'
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(26)
        if literal:
            a = self.star_named_expressions()
            if a:
                literal_1 = self.expect_type(27)
                if literal_1:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . Set ( elts = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def dict(self): # type Optional[ast . Dict]
        # dict: '{' double_starred_kvpairs? '}' | '{' invalid_double_starred_kvpairs '}'
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(26)
        if literal:
            a = self.double_starred_kvpairs()
            if True:
                literal_1 = self.expect_type(27)
                if literal_1:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . Dict ( keys = [kv [0] for kv in a] if a else None , values = [kv [1] for kv in a] if a else None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(26)
        if literal:
            invalid_double_starred_kvpairs = self.invalid_double_starred_kvpairs()
            if invalid_double_starred_kvpairs:
                literal_1 = self.expect_type(27)
                if literal_1:
                    return None  # pragma: no cover
        self._reset(mark)
        return None

    @logger
    def double_starred_kvpairs(self): # type Optional[list]
        # double_starred_kvpairs: ','.double_starred_kvpair+ ','?
        mark = self._mark()
        a = self._gather_109()
        if a:
            opt = self.expect_type(12)
            if True:
                return a
        self._reset(mark)
        return None

    @logger
    def double_starred_kvpair(self): # type Optional[Any]
        # double_starred_kvpair: '**' bitwise_or | kvpair
        mark = self._mark()
        literal = self.expect_type(36)
        if literal:
            a = self.bitwise_or()
            if a:
                return ( None , a )
        self._reset(mark)
        kvpair = self.kvpair()
        if kvpair:
            return kvpair
        self._reset(mark)
        return None

    @logger
    def kvpair(self): # type Optional[tuple]
        # kvpair: expression ':' expression
        mark = self._mark()
        a = self.expression()
        if a:
            literal = self.expect_type(11)
            if literal:
                b = self.expression()
                if b:
                    return ( a , b )
        self._reset(mark)
        return None

    @logger
    def for_if_clauses(self): # type Optional[List [ast . comprehension]]
        # for_if_clauses: for_if_clause+
        mark = self._mark()
        a = self._loop1_111()
        if a:
            return a
        self._reset(mark)
        return None

    @logger
    def for_if_clause(self): # type Optional[ast . comprehension]
        # for_if_clause: ASYNC 'for' star_targets 'in' ~ disjunction (('if' disjunction))* | 'for' star_targets 'in' ~ disjunction (('if' disjunction))* | invalid_for_target
        mark = self._mark()
        cut = False
        _async = self.expect_type(58)
        if _async:
            literal = self.expect_type(518)
            if literal:
                a = self.star_targets()
                if a:
                    literal_1 = self.expect_type(519)
                    if literal_1:
                        cut = True
                        if cut:
                            b = self.disjunction()
                            if b:
                                c = self._loop0_112()
                                if True:
                                    return self . check_version ( ( 3 , 6 ) , "Async comprehensions are" , ast . comprehension ( target = a , iter = b , ifs = c if c else None , is_async = True ) )
        self._reset(mark)
        if cut: return None
        cut = False
        literal = self.expect_type(518)
        if literal:
            a = self.star_targets()
            if a:
                literal_1 = self.expect_type(519)
                if literal_1:
                    cut = True
                    if cut:
                        b = self.disjunction()
                        if b:
                            c = self._loop0_113()
                            if True:
                                return ast . comprehension ( target = a , iter = b , ifs = c if c else None , is_async = False )
        self._reset(mark)
        if cut: return None
        if self.call_invalid_rules:
            invalid_for_target = self.invalid_for_target()
            if invalid_for_target:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def listcomp(self): # type Optional[ast . ListComp]
        # listcomp: '[' named_expression for_if_clauses ']' | invalid_comprehension
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(9)
        if literal:
            a = self.named_expression()
            if a:
                b = self.for_if_clauses()
                if b:
                    literal_1 = self.expect_type(10)
                    if literal_1:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . ListComp ( elt = a , generators = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_comprehension = self.invalid_comprehension()
            if invalid_comprehension:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def setcomp(self): # type Optional[ast . SetComp]
        # setcomp: '{' named_expression for_if_clauses '}' | invalid_comprehension
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(26)
        if literal:
            a = self.named_expression()
            if a:
                b = self.for_if_clauses()
                if b:
                    literal_1 = self.expect_type(27)
                    if literal_1:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . SetComp ( elt = a , generators = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_comprehension = self.invalid_comprehension()
            if invalid_comprehension:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def genexp(self): # type Optional[ast . GeneratorExp]
        # genexp: '(' (assignment_expression | expression !':=') for_if_clauses ')' | invalid_comprehension
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(7)
        if literal:
            a = self._tmp_114()
            if a:
                b = self.for_if_clauses()
                if b:
                    literal_1 = self.expect_type(8)
                    if literal_1:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . GeneratorExp ( elt = a , generators = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_comprehension = self.invalid_comprehension()
            if invalid_comprehension:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def dictcomp(self): # type Optional[ast . DictComp]
        # dictcomp: '{' kvpair for_if_clauses '}' | invalid_dict_comprehension
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(26)
        if literal:
            a = self.kvpair()
            if a:
                b = self.for_if_clauses()
                if b:
                    literal_1 = self.expect_type(27)
                    if literal_1:
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . DictComp ( key = a [0] , value = a [1] , generators = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_dict_comprehension = self.invalid_dict_comprehension()
            if invalid_dict_comprehension:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @memoize
    def arguments(self): # type Optional[Tuple [list , list]]
        # arguments: args ','? &')' | invalid_arguments
        mark = self._mark()
        a = self.args()
        if a:
            opt = self.expect_type(12)
            if True:
                
                if self.positive_lookahead(self.expect_type, 8):
                    return a
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_arguments = self.invalid_arguments()
            if invalid_arguments:
                return None  # pragma: no cover
            self._reset(mark)
        return None

    @logger
    def args(self): # type Optional[Tuple [list , list]]
        # args: ','.(starred_expression | (assignment_expression | expression !':=') !'=')+ [',' kwargs] | kwargs
        mark = self._mark()
        a = self._gather_115()
        if a:
            b = self._tmp_117()
            if True:
                return ( a + ( [e for e in b if isinstance ( e , ast . Starred )] if b else [] ) , ( [e for e in b if not isinstance ( e , ast . Starred )] if b else [] ) )
        self._reset(mark)
        a = self.kwargs()
        if a:
            return ( [e for e in a if isinstance ( e , ast . Starred )] , [e for e in a if not isinstance ( e , ast . Starred )] )
        self._reset(mark)
        return None

    @logger
    def kwargs(self): # type Optional[list]
        # kwargs: ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+ | ','.kwarg_or_starred+ | ','.kwarg_or_double_starred+
        mark = self._mark()
        a = self._gather_118()
        if a:
            literal = self.expect_type(12)
            if literal:
                b = self._gather_120()
                if b:
                    return a + b
        self._reset(mark)
        _gather_122 = self._gather_122()
        if _gather_122:
            return _gather_122
        self._reset(mark)
        _gather_124 = self._gather_124()
        if _gather_124:
            return _gather_124
        self._reset(mark)
        return None

    @logger
    def starred_expression(self): # type Optional[Any]
        # starred_expression: '*' expression
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(16)
        if literal:
            a = self.expression()
            if a:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . Starred ( value = a , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def kwarg_or_starred(self): # type Optional[Any]
        # kwarg_or_starred: invalid_kwarg | NAME '=' expression | starred_expression
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        if self.call_invalid_rules:
            invalid_kwarg = self.invalid_kwarg()
            if invalid_kwarg:
                return None  # pragma: no cover
            self._reset(mark)
        a = self.name()
        if a:
            literal = self.expect_type(22)
            if literal:
                b = self.expression()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . keyword ( arg = self . check_for_forbidden_assignment_target ( a ) , value = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.starred_expression()
        if a:
            return a
        self._reset(mark)
        return None

    @logger
    def kwarg_or_double_starred(self): # type Optional[Any]
        # kwarg_or_double_starred: invalid_kwarg | NAME '=' expression | '**' expression
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        if self.call_invalid_rules:
            invalid_kwarg = self.invalid_kwarg()
            if invalid_kwarg:
                return None  # pragma: no cover
            self._reset(mark)
        a = self.name()
        if a:
            literal = self.expect_type(22)
            if literal:
                b = self.expression()
                if b:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . keyword ( arg = self . check_for_forbidden_assignment_target ( a ) , value = b , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(36)
        if literal:
            a = self.expression()
            if a:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . keyword ( arg = None , value = a , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def star_targets(self): # type Optional[Any]
        # star_targets: star_target !',' | star_target ((',' star_target))* ','?
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.star_target()
        if a:
            
            if self.negative_lookahead(self.expect_type, 12):
                return a
        self._reset(mark)
        a = self.star_target()
        if a:
            b = self._loop0_126()
            if True:
                opt = self.expect_type(12)
                if True:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . Tuple ( elts = [a] + b , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def star_targets_list_seq(self): # type Optional[list]
        # star_targets_list_seq: ','.star_target+ ','?
        mark = self._mark()
        a = self._gather_127()
        if a:
            opt = self.expect_type(12)
            if True:
                return a
        self._reset(mark)
        return None

    @logger
    def star_targets_tuple_seq(self): # type Optional[list]
        # star_targets_tuple_seq: star_target ((',' star_target))+ ','? | star_target ','
        mark = self._mark()
        a = self.star_target()
        if a:
            b = self._loop1_129()
            if b:
                opt = self.expect_type(12)
                if True:
                    return [a] + b
        self._reset(mark)
        a = self.star_target()
        if a:
            literal = self.expect_type(12)
            if literal:
                return [a]
        self._reset(mark)
        return None

    @memoize
    def star_target(self): # type Optional[Any]
        # star_target: '*' (!'*' star_target) | target_with_star_atom
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        literal = self.expect_type(16)
        if literal:
            a = self._tmp_130()
            if a:
                tok = self.get_last_non_whitespace_token()
                end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                return ast . Starred ( value = self . set_expr_context ( a , Store ) , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        target_with_star_atom = self.target_with_star_atom()
        if target_with_star_atom:
            return target_with_star_atom
        self._reset(mark)
        return None

    @memoize
    def target_with_star_atom(self): # type Optional[Any]
        # target_with_star_atom: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | star_atom
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.t_primary()
        if a:
            literal = self.expect_type(23)
            if literal:
                b = self.name()
                if b:
                    
                    if self.negative_lookahead(self.t_lookahead, ):
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . Attribute ( value = a , attr = b . id , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.t_primary()
        if a:
            literal = self.expect_type(9)
            if literal:
                b = self.slices()
                if b:
                    literal_1 = self.expect_type(10)
                    if literal_1:
                        
                        if self.negative_lookahead(self.t_lookahead, ):
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return ast . Subscript ( value = a , slice = b , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        star_atom = self.star_atom()
        if star_atom:
            return star_atom
        self._reset(mark)
        return None

    @logger
    def star_atom(self): # type Optional[Any]
        # star_atom: NAME | '(' target_with_star_atom ')' | '(' star_targets_tuple_seq? ')' | '[' star_targets_list_seq? ']'
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.name()
        if a:
            return self . set_expr_context ( a , Store )
        self._reset(mark)
        literal = self.expect_type(7)
        if literal:
            a = self.target_with_star_atom()
            if a:
                literal_1 = self.expect_type(8)
                if literal_1:
                    return self . set_expr_context ( a , Store )
        self._reset(mark)
        literal = self.expect_type(7)
        if literal:
            a = self.star_targets_tuple_seq()
            if True:
                literal_1 = self.expect_type(8)
                if literal_1:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . Tuple ( elts = a , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(9)
        if literal:
            a = self.star_targets_list_seq()
            if True:
                literal_1 = self.expect_type(10)
                if literal_1:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . List ( elts = a , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def single_target(self): # type Optional[Any]
        # single_target: single_subscript_attribute_target | NAME | '(' single_target ')'
        mark = self._mark()
        single_subscript_attribute_target = self.single_subscript_attribute_target()
        if single_subscript_attribute_target:
            return single_subscript_attribute_target
        self._reset(mark)
        a = self.name()
        if a:
            return self . set_expr_context ( a , Store )
        self._reset(mark)
        literal = self.expect_type(7)
        if literal:
            a = self.single_target()
            if a:
                literal_1 = self.expect_type(8)
                if literal_1:
                    return a
        self._reset(mark)
        return None

    @logger
    def single_subscript_attribute_target(self): # type Optional[Any]
        # single_subscript_attribute_target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.t_primary()
        if a:
            literal = self.expect_type(23)
            if literal:
                b = self.name()
                if b:
                    
                    if self.negative_lookahead(self.t_lookahead, ):
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . Attribute ( value = a , attr = b . id , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.t_primary()
        if a:
            literal = self.expect_type(9)
            if literal:
                b = self.slices()
                if b:
                    literal_1 = self.expect_type(10)
                    if literal_1:
                        
                        if self.negative_lookahead(self.t_lookahead, ):
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return ast . Subscript ( value = a , slice = b , ctx = Store , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @memoize_left_rec
    def t_primary(self): # type Optional[Any]
        # t_primary: t_primary '.' NAME &t_lookahead | t_primary '[' slices ']' &t_lookahead | t_primary genexp &t_lookahead | t_primary '(' arguments? ')' &t_lookahead | atom &t_lookahead
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.t_primary()
        if a:
            literal = self.expect_type(23)
            if literal:
                b = self.name()
                if b:
                    
                    if self.positive_lookahead(self.t_lookahead, ):
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . Attribute ( value = a , attr = b . id , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.t_primary()
        if a:
            literal = self.expect_type(9)
            if literal:
                b = self.slices()
                if b:
                    literal_1 = self.expect_type(10)
                    if literal_1:
                        
                        if self.positive_lookahead(self.t_lookahead, ):
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return ast . Subscript ( value = a , slice = b , ctx = Load , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.t_primary()
        if a:
            b = self.genexp()
            if b:
                
                if self.positive_lookahead(self.t_lookahead, ):
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . Call ( func = a , args = [b] , keywords = None , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.t_primary()
        if a:
            literal = self.expect_type(7)
            if literal:
                b = self.arguments()
                if True:
                    literal_1 = self.expect_type(8)
                    if literal_1:
                        
                        if self.positive_lookahead(self.t_lookahead, ):
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return ast . Call ( func = a , args = b [0] if b else None , keywords = self . check_repeated_keywords ( b ) , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset , )
        self._reset(mark)
        a = self.atom()
        if a:
            
            if self.positive_lookahead(self.t_lookahead, ):
                return a
        self._reset(mark)
        return None

    @logger
    def t_lookahead(self): # type Optional[Any]
        # t_lookahead: '(' | '[' | '.'
        mark = self._mark()
        literal = self.expect_type(7)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(9)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(23)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def del_targets(self): # type Optional[Any]
        # del_targets: ','.del_target+ ','?
        mark = self._mark()
        a = self._gather_131()
        if a:
            opt = self.expect_type(12)
            if True:
                return a
        self._reset(mark)
        return None

    @memoize
    def del_target(self): # type Optional[Any]
        # del_target: t_primary '.' NAME !t_lookahead | t_primary '[' slices ']' !t_lookahead | del_t_atom
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.t_primary()
        if a:
            literal = self.expect_type(23)
            if literal:
                b = self.name()
                if b:
                    
                    if self.negative_lookahead(self.t_lookahead, ):
                        tok = self.get_last_non_whitespace_token()
                        end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                        return ast . Attribute ( value = a , attr = b . id , ctx = Del , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        a = self.t_primary()
        if a:
            literal = self.expect_type(9)
            if literal:
                b = self.slices()
                if b:
                    literal_1 = self.expect_type(10)
                    if literal_1:
                        
                        if self.negative_lookahead(self.t_lookahead, ):
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return ast . Subscript ( value = a , slice = b , ctx = Del , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        del_t_atom = self.del_t_atom()
        if del_t_atom:
            return del_t_atom
        self._reset(mark)
        return None

    @logger
    def del_t_atom(self): # type Optional[Any]
        # del_t_atom: NAME | '(' del_target ')' | '(' del_targets? ')' | '[' del_targets? ']'
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.name()
        if a:
            return self . set_expr_context ( a , Del )
        self._reset(mark)
        literal = self.expect_type(7)
        if literal:
            a = self.del_target()
            if a:
                literal_1 = self.expect_type(8)
                if literal_1:
                    return self . set_expr_context ( a , Del )
        self._reset(mark)
        literal = self.expect_type(7)
        if literal:
            a = self.del_targets()
            if True:
                literal_1 = self.expect_type(8)
                if literal_1:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . Tuple ( elts = a , ctx = Del , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        literal = self.expect_type(9)
        if literal:
            a = self.del_targets()
            if True:
                literal_1 = self.expect_type(10)
                if literal_1:
                    tok = self.get_last_non_whitespace_token()
                    end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                    return ast . List ( elts = a , ctx = Del , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        return None

    @logger
    def type_expressions(self): # type Optional[list]
        # type_expressions: ','.expression+ ',' '*' expression ',' '**' expression | ','.expression+ ',' '*' expression | ','.expression+ ',' '**' expression | '*' expression ',' '**' expression | '*' expression | '**' expression | ','.expression+
        mark = self._mark()
        a = self._gather_133()
        if a:
            literal = self.expect_type(12)
            if literal:
                literal_1 = self.expect_type(16)
                if literal_1:
                    b = self.expression()
                    if b:
                        literal_2 = self.expect_type(12)
                        if literal_2:
                            literal_3 = self.expect_type(36)
                            if literal_3:
                                c = self.expression()
                                if c:
                                    return a + [b , c]
        self._reset(mark)
        a = self._gather_135()
        if a:
            literal = self.expect_type(12)
            if literal:
                literal_1 = self.expect_type(16)
                if literal_1:
                    b = self.expression()
                    if b:
                        return a + [b]
        self._reset(mark)
        a = self._gather_137()
        if a:
            literal = self.expect_type(12)
            if literal:
                literal_1 = self.expect_type(36)
                if literal_1:
                    b = self.expression()
                    if b:
                        return a + [b]
        self._reset(mark)
        literal = self.expect_type(16)
        if literal:
            a = self.expression()
            if a:
                literal_1 = self.expect_type(12)
                if literal_1:
                    literal_2 = self.expect_type(36)
                    if literal_2:
                        b = self.expression()
                        if b:
                            return [a , b]
        self._reset(mark)
        literal = self.expect_type(16)
        if literal:
            a = self.expression()
            if a:
                return [a]
        self._reset(mark)
        literal = self.expect_type(36)
        if literal:
            a = self.expression()
            if a:
                return [a]
        self._reset(mark)
        a = self._gather_139()
        if a:
            return a
        self._reset(mark)
        return None

    @logger
    def func_type_comment(self): # type Optional[Any]
        # func_type_comment: NEWLINE TYPE_COMMENT &(NEWLINE INDENT) | invalid_double_type_comments | TYPE_COMMENT
        mark = self._mark()
        _newline = self.expect_type(4)
        if _newline:
            t = self.type_comment()
            if t:
                
                if self.positive_lookahead(self._tmp_141, ):
                    return t
        self._reset(mark)
        if self.call_invalid_rules:
            invalid_double_type_comments = self.invalid_double_type_comments()
            if invalid_double_type_comments:
                return None  # pragma: no cover
            self._reset(mark)
        type_comment = self.type_comment()
        if type_comment:
            return type_comment
        self._reset(mark)
        return None

    @logger
    def invalid_arguments(self): # type Optional[NoReturn]
        # invalid_arguments: args ',' '*' | expression for_if_clauses ',' [args | expression for_if_clauses] | NAME '=' expression for_if_clauses | args for_if_clauses | args ',' expression for_if_clauses | args ',' args
        mark = self._mark()
        a = self.args()
        if a:
            literal = self.expect_type(12)
            if literal:
                literal_1 = self.expect_type(16)
                if literal_1:
                    return self . raise_syntax_error_known_location_ast ( "iterable argument unpacking follows keyword argument unpacking" , a [1] [- 1] if a [1] else a [0] [- 1] , )
        self._reset(mark)
        a = self.expression()
        if a:
            b = self.for_if_clauses()
            if b:
                literal = self.expect_type(12)
                if literal:
                    opt = self._tmp_142()
                    if True:
                        return self . raise_syntax_error_known_range ( "Generator expression must be parenthesized" , a , b [- 1] . target )
        self._reset(mark)
        a = self.name()
        if a:
            b = self.expect_type(22)
            if b:
                expression = self.expression()
                if expression:
                    for_if_clauses = self.for_if_clauses()
                    if for_if_clauses:
                        return self . raise_syntax_error_known_range ( "invalid syntax. Maybe you meant '==' or ':=' instead of '='?" , a , b )
        self._reset(mark)
        a = self.args()
        if a:
            for_if_clauses = self.for_if_clauses()
            if for_if_clauses:
                return self . raise_syntax_error_starting_from ( "Generator expression must be parenthesized" , a [1] [- 1] if a [1] else a [0] [- 1] )
        self._reset(mark)
        args = self.args()
        if args:
            literal = self.expect_type(12)
            if literal:
                a = self.expression()
                if a:
                    b = self.for_if_clauses()
                    if b:
                        return self . raise_syntax_error_known_range ( "Generator expression must be parenthesized" , a , b [- 1] . target , )
        self._reset(mark)
        a = self.args()
        if a:
            literal = self.expect_type(12)
            if literal:
                args = self.args()
                if args:
                    return self . raise_syntax_error ( "positional argument follows keyword argument unpacking" if a [1] [- 1] . arg is None else "positional argument follows keyword argument" , )
        self._reset(mark)
        return None

    @logger
    def invalid_kwarg(self): # type Optional[NoReturn]
        # invalid_kwarg: NAME '=' expression for_if_clauses | !(NAME '=') expression '='
        mark = self._mark()
        a = self.name()
        if a:
            b = self.expect_type(22)
            if b:
                expression = self.expression()
                if expression:
                    for_if_clauses = self.for_if_clauses()
                    if for_if_clauses:
                        return self . raise_syntax_error_known_range ( "invalid syntax. Maybe you meant '==' or ':=' instead of '='?" , a , b )
        self._reset(mark)
        
        if self.negative_lookahead(self._tmp_143, ):
            a = self.expression()
            if a:
                b = self.expect_type(22)
                if b:
                    return self . kwarg_illegal_assignment ( a , b )
        self._reset(mark)
        return None

    @logger
    def expression_without_invalid(self): # type Optional[ast . AST]
        # expression_without_invalid: disjunction 'if' disjunction 'else' expression | disjunction | lambdef
        mark = self._mark()
        tok = self.peek()
        start_lineno, start_col_offset = tok.lineno, tok.column
        a = self.disjunction()
        if a:
            literal = self.expect_type(509)
            if literal:
                b = self.disjunction()
                if b:
                    literal_1 = self.expect_type(517)
                    if literal_1:
                        c = self.expression()
                        if c:
                            tok = self.get_last_non_whitespace_token()
                            end_lineno, end_col_offset = tok.end_lineno, tok.end_column
                            return ast . IfExp ( body = b , test = a , orelse = c , lineno=start_lineno, col_offset=start_col_offset, end_lineno=end_lineno, end_col_offset=end_col_offset )
        self._reset(mark)
        disjunction = self.disjunction()
        if disjunction:
            return disjunction
        self._reset(mark)
        lambdef = self.lambdef()
        if lambdef:
            return lambdef
        self._reset(mark)
        return None

    @logger
    def invalid_legacy_expression(self): # type Optional[Any]
        # invalid_legacy_expression: NAME !'(' expression_without_invalid
        mark = self._mark()
        a = self.name()
        if a:
            
            if self.negative_lookahead(self.expect_type, 7):
                b = self.expression_without_invalid()
                if b:
                    return self . raise_syntax_error_known_range ( "Missing parentheses in call to '%s'. Did you mean '%s'(...)?" % ( a . id , a . id ) , a , b , ) if a . id in ( "exec" , "print" ) else None
        self._reset(mark)
        return None

    @logger
    def invalid_expression(self): # type Optional[NoReturn]
        # invalid_expression: invalid_legacy_expression | !(NAME STRING | SOFT_KEYWORD) disjunction expression_without_invalid | disjunction 'if' disjunction !('else' | ':')
        mark = self._mark()
        if self.call_invalid_rules:
            invalid_legacy_expression = self.invalid_legacy_expression()
            if invalid_legacy_expression:
                return None  # pragma: no cover
            self._reset(mark)
        
        if self.negative_lookahead(self._tmp_144, ):
            a = self.disjunction()
            if a:
                b = self.expression_without_invalid()
                if b:
                    return self . raise_syntax_error_known_range ( "invalid syntax. Perhaps you forgot a comma?" , a , b )
        self._reset(mark)
        a = self.disjunction()
        if a:
            literal = self.expect_type(509)
            if literal:
                b = self.disjunction()
                if b:
                    
                    if self.negative_lookahead(self._tmp_145, ):
                        return self . raise_syntax_error_known_range ( "expected 'else' after 'if' expression" , a , b )
        self._reset(mark)
        return None

    @logger
    def invalid_named_expression(self): # type Optional[NoReturn]
        # invalid_named_expression: expression ':=' expression | NAME '=' bitwise_or !('=' | ':=') | !(list | tuple | genexp | 'True' | 'None' | 'False') bitwise_or '=' bitwise_or !('=' | ':=')
        mark = self._mark()
        a = self.expression()
        if a:
            literal = self.expect_type(54)
            if literal:
                expression = self.expression()
                if expression:
                    return self . raise_syntax_error_known_location_ast ( "cannot use assignment expressions with %s" % ( self . get_expr_name ( a ) , ) , a )
        self._reset(mark)
        a = self.name()
        if a:
            literal = self.expect_type(22)
            if literal:
                b = self.bitwise_or()
                if b:
                    
                    if self.negative_lookahead(self._tmp_146, ):
                        return ( None if self . in_recursive_rule else self . raise_syntax_error_known_range ( "invalid syntax. Maybe you meant '==' or ':=' instead of '='?" , a , b ) )
        self._reset(mark)
        
        if self.negative_lookahead(self._tmp_147, ):
            a = self.bitwise_or()
            if a:
                b = self.expect_type(22)
                if b:
                    bitwise_or = self.bitwise_or()
                    if bitwise_or:
                        
                        if self.negative_lookahead(self._tmp_148, ):
                            return ( None if self . in_recursive_rule else self . raise_syntax_error_known_range ( "cannot assign to %s here. Maybe you meant '==' instead of '='?" % ( self . get_expr_name ( a ) , ) , a , b ) )
        self._reset(mark)
        return None

    @logger
    def invalid_assignment(self): # type Optional[NoReturn]
        # invalid_assignment: invalid_ann_assign_target ':' expression | star_named_expression ',' star_named_expressions* ':' expression | expression ':' expression | ((star_targets '='))* star_expressions '=' | ((star_targets '='))* yield_expr '=' | star_expressions augassign (yield_expr | star_expressions)
        mark = self._mark()
        a = self.invalid_ann_assign_target()
        if a:
            literal = self.expect_type(11)
            if literal:
                expression = self.expression()
                if expression:
                    return self . raise_syntax_error_known_location_ast ( "only single target (not %s) can be annotated" % ( self . get_expr_name ( a ) , ) , a )
        self._reset(mark)
        a = self.star_named_expression()
        if a:
            literal = self.expect_type(12)
            if literal:
                _loop0_149 = self._loop0_149()
                if True:
                    literal_1 = self.expect_type(11)
                    if literal_1:
                        expression = self.expression()
                        if expression:
                            return self . raise_syntax_error_known_location_ast ( "only single target (not tuple) can be annotated" , a )
        self._reset(mark)
        a = self.expression()
        if a:
            literal = self.expect_type(11)
            if literal:
                expression = self.expression()
                if expression:
                    return self . raise_syntax_error_known_location_ast ( "illegal target for annotation" , a )
        self._reset(mark)
        _loop0_150 = self._loop0_150()
        if True:
            a = self.star_expressions()
            if a:
                literal = self.expect_type(22)
                if literal:
                    return self . raise_syntax_error_known_location_ast ( "cannot assign to %s" % ( self . get_expr_name ( a ) , ) , a )
        self._reset(mark)
        _loop0_151 = self._loop0_151()
        if True:
            a = self.yield_expr()
            if a:
                literal = self.expect_type(22)
                if literal:
                    return self . raise_syntax_error_known_location_ast ( "assignment to yield expression not possible" , a )
        self._reset(mark)
        a = self.star_expressions()
        if a:
            augassign = self.augassign()
            if augassign:
                _tmp_152 = self._tmp_152()
                if _tmp_152:
                    return self . raise_syntax_error_known_location_ast ( "%s is an illegal expression for augmented assignment" % ( self . get_expr_name ( a ) , ) , a )
        self._reset(mark)
        return None

    @logger
    def invalid_ann_assign_target(self): # type Optional[ast . AST]
        # invalid_ann_assign_target: list | tuple | '(' invalid_ann_assign_target ')'
        mark = self._mark()
        a = self.list()
        if a:
            return a
        self._reset(mark)
        a = self.tuple()
        if a:
            return a
        self._reset(mark)
        literal = self.expect_type(7)
        if literal:
            a = self.invalid_ann_assign_target()
            if a:
                literal_1 = self.expect_type(8)
                if literal_1:
                    return a
        self._reset(mark)
        return None

    @logger
    def invalid_del_stmt(self): # type Optional[NoReturn]
        # invalid_del_stmt: 'del' star_expressions
        mark = self._mark()
        literal = self.expect_type(502)
        if literal:
            a = self.star_expressions()
            if a:
                return self . raise_syntax_error_known_location_ast ( "cannot delete %s" % ( self . get_expr_name ( a ) , ) , a )
        self._reset(mark)
        return None

    @logger
    def invalid_block(self): # type Optional[NoReturn]
        # invalid_block: NEWLINE !INDENT
        mark = self._mark()
        _newline = self.expect_type(4)
        if _newline:
            
            if self.negative_lookahead(self.expect_type, 5):
                return self . raise_indentation_error ( "expected an indented block" )
        self._reset(mark)
        return None

    @logger
    def invalid_comprehension(self): # type Optional[NoReturn]
        # invalid_comprehension: ('[' | '(' | '{') starred_expression for_if_clauses | ('[' | '{') star_named_expression ',' star_named_expressions for_if_clauses | ('[' | '{') star_named_expression ',' for_if_clauses
        mark = self._mark()
        _tmp_153 = self._tmp_153()
        if _tmp_153:
            a = self.starred_expression()
            if a:
                for_if_clauses = self.for_if_clauses()
                if for_if_clauses:
                    return self . raise_syntax_error_known_location_ast ( "iterable unpacking cannot be used in comprehension" , a )
        self._reset(mark)
        _tmp_154 = self._tmp_154()
        if _tmp_154:
            a = self.star_named_expression()
            if a:
                literal = self.expect_type(12)
                if literal:
                    b = self.star_named_expressions()
                    if b:
                        for_if_clauses = self.for_if_clauses()
                        if for_if_clauses:
                            return self . raise_syntax_error_known_range ( "did you forget parentheses around the comprehension target?" , a , b [- 1] )
        self._reset(mark)
        _tmp_155 = self._tmp_155()
        if _tmp_155:
            a = self.star_named_expression()
            if a:
                b = self.expect_type(12)
                if b:
                    for_if_clauses = self.for_if_clauses()
                    if for_if_clauses:
                        return self . raise_syntax_error_known_range ( "did you forget parentheses around the comprehension target?" , a , b )
        self._reset(mark)
        return None

    @logger
    def invalid_dict_comprehension(self): # type Optional[NoReturn]
        # invalid_dict_comprehension: '{' '**' bitwise_or for_if_clauses '}'
        mark = self._mark()
        literal = self.expect_type(26)
        if literal:
            a = self.expect_type(36)
            if a:
                bitwise_or = self.bitwise_or()
                if bitwise_or:
                    for_if_clauses = self.for_if_clauses()
                    if for_if_clauses:
                        literal_1 = self.expect_type(27)
                        if literal_1:
                            return self . raise_syntax_error_known_location_ast ( "dict unpacking cannot be used in dict comprehension" , a )
        self._reset(mark)
        return None

    @logger
    def invalid_parameters(self): # type Optional[NoReturn]
        # invalid_parameters: param_no_default* invalid_parameters_helper param_no_default
        mark = self._mark()
        _loop0_156 = self._loop0_156()
        if True:
            invalid_parameters_helper = self.invalid_parameters_helper()
            if invalid_parameters_helper:
                a = self.param_no_default()
                if a:
                    return self . raise_syntax_error_known_location_ast ( "non-default argument follows default argument" , a )
        self._reset(mark)
        return None

    @logger
    def invalid_parameters_helper(self): # type Optional[Any]
        # invalid_parameters_helper: slash_with_default | param_with_default+
        mark = self._mark()
        a = self.slash_with_default()
        if a:
            return [a]
        self._reset(mark)
        a = self._loop1_157()
        if a:
            return a
        self._reset(mark)
        return None

    @logger
    def invalid_lambda_parameters(self): # type Optional[NoReturn]
        # invalid_lambda_parameters: lambda_param_no_default* invalid_lambda_parameters_helper lambda_param_no_default
        mark = self._mark()
        _loop0_158 = self._loop0_158()
        if True:
            invalid_lambda_parameters_helper = self.invalid_lambda_parameters_helper()
            if invalid_lambda_parameters_helper:
                a = self.lambda_param_no_default()
                if a:
                    return self . raise_syntax_error_known_location_ast ( "non-default argument follows default argument" , a )
        self._reset(mark)
        return None

    @logger
    def invalid_lambda_parameters_helper(self): # type Optional[NoReturn]
        # invalid_lambda_parameters_helper: lambda_slash_with_default | lambda_param_with_default+
        mark = self._mark()
        a = self.lambda_slash_with_default()
        if a:
            return [a]
        self._reset(mark)
        a = self._loop1_159()
        if a:
            return a
        self._reset(mark)
        return None

    @logger
    def invalid_star_etc(self): # type Optional[NoReturn]
        # invalid_star_etc: '*' (')' | ',' (')' | '**')) | '*' ',' TYPE_COMMENT
        mark = self._mark()
        a = self.expect_type(16)
        if a:
            _tmp_160 = self._tmp_160()
            if _tmp_160:
                return self . raise_syntax_error_known_location_tok ( "named arguments must follow bare *" , a )
        self._reset(mark)
        literal = self.expect_type(16)
        if literal:
            literal_1 = self.expect_type(12)
            if literal_1:
                type_comment = self.type_comment()
                if type_comment:
                    return self . raise_syntax_error ( "bare * has associated type comment" )
        self._reset(mark)
        return None

    @logger
    def invalid_lambda_star_etc(self): # type Optional[NoReturn]
        # invalid_lambda_star_etc: '*' (':' | ',' (':' | '**'))
        mark = self._mark()
        literal = self.expect_type(16)
        if literal:
            _tmp_161 = self._tmp_161()
            if _tmp_161:
                return self . raise_syntax_error ( "named arguments must follow bare *" )
        self._reset(mark)
        return None

    @logger
    def invalid_double_type_comments(self): # type Optional[NoReturn]
        # invalid_double_type_comments: TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT
        mark = self._mark()
        type_comment = self.type_comment()
        if type_comment:
            _newline = self.expect_type(4)
            if _newline:
                type_comment_1 = self.type_comment()
                if type_comment_1:
                    _newline_1 = self.expect_type(4)
                    if _newline_1:
                        _indent = self.expect_type(5)
                        if _indent:
                            return self . raise_syntax_error ( "Cannot have two type comments on def" )
        self._reset(mark)
        return None

    @logger
    def invalid_with_item(self): # type Optional[NoReturn]
        # invalid_with_item: expression 'as' expression &(',' | ')' | ':')
        mark = self._mark()
        expression = self.expression()
        if expression:
            literal = self.expect_type(521)
            if literal:
                a = self.expression()
                if a:
                    
                    if self.positive_lookahead(self._tmp_162, ):
                        return self . raise_syntax_error_known_location_ast ( "cannot assign to %s" % ( self . get_expr_name ( a ) , ) , a )
        self._reset(mark)
        return None

    @logger
    def invalid_for_target(self): # type Optional[NoReturn]
        # invalid_for_target: ASYNC? 'for' star_expressions
        mark = self._mark()
        opt = self.expect_type(58)
        if True:
            literal = self.expect_type(518)
            if literal:
                a = self.star_expressions()
                if a:
                    return self . raise_syntax_error_known_location_ast ( "cannot assign to %s" % ( self . get_expr_name ( a ) , ) , a )
        self._reset(mark)
        return None

    @logger
    def invalid_group(self): # type Optional[NoReturn]
        # invalid_group: '(' starred_expression ')' | '(' '**' expression ')'
        mark = self._mark()
        literal = self.expect_type(7)
        if literal:
            a = self.starred_expression()
            if a:
                literal_1 = self.expect_type(8)
                if literal_1:
                    return self . raise_syntax_error_known_location_ast ( "cannot use starred expression here" , a )
        self._reset(mark)
        literal = self.expect_type(7)
        if literal:
            a = self.expect_type(36)
            if a:
                expression = self.expression()
                if expression:
                    literal_1 = self.expect_type(8)
                    if literal_1:
                        return self . raise_syntax_error_known_location_tok ( "cannot use double starred expression here" , a )
        self._reset(mark)
        return None

    @logger
    def invalid_import_from_targets(self): # type Optional[NoReturn]
        # invalid_import_from_targets: import_from_as_names ',' NEWLINE
        mark = self._mark()
        import_from_as_names = self.import_from_as_names()
        if import_from_as_names:
            a = self.expect_type(12)
            if a:
                _newline = self.expect_type(4)
                if _newline:
                    return self . raise_syntax_error_known_location_tok ( "trailing comma not allowed without surrounding parentheses" , a )
        self._reset(mark)
        return None

    @logger
    def invalid_with_stmt(self): # type Optional[None]
        # invalid_with_stmt: ASYNC? 'with' ','.(expression ['as' star_target])+ &&':' | ASYNC? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' &&':'
        mark = self._mark()
        opt = self.expect_type(58)
        if True:
            literal = self.expect_type(520)
            if literal:
                _gather_163 = self._gather_163()
                if _gather_163:
                    literal_1 = self.expect_forced(self.expect_type(11), "':'")
                    if literal_1:
                        return None  # pragma: no cover
        self._reset(mark)
        opt = self.expect_type(58)
        if True:
            literal = self.expect_type(520)
            if literal:
                literal_1 = self.expect_type(7)
                if literal_1:
                    _gather_165 = self._gather_165()
                    if _gather_165:
                        opt_1 = self.expect_type(12)
                        if True:
                            literal_2 = self.expect_type(8)
                            if literal_2:
                                literal_3 = self.expect_forced(self.expect_type(11), "':'")
                                if literal_3:
                                    return None  # pragma: no cover
        self._reset(mark)
        return None

    @logger
    def invalid_with_stmt_indent(self): # type Optional[NoReturn]
        # invalid_with_stmt_indent: ASYNC? 'with' ','.(expression ['as' star_target])+ ':' NEWLINE !INDENT | ASYNC? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' ':' NEWLINE !INDENT
        mark = self._mark()
        opt = self.expect_type(58)
        if True:
            a = self.expect_type(520)
            if a:
                _gather_167 = self._gather_167()
                if _gather_167:
                    literal = self.expect_type(11)
                    if literal:
                        _newline = self.expect_type(4)
                        if _newline:
                            
                            if self.negative_lookahead(self.expect_type, 5):
                                return self . raise_indentation_error ( "expected an indented block after 'with' statement on line %s" % a . lineno )
        self._reset(mark)
        opt = self.expect_type(58)
        if True:
            a = self.expect_type(520)
            if a:
                literal = self.expect_type(7)
                if literal:
                    _gather_169 = self._gather_169()
                    if _gather_169:
                        opt_1 = self.expect_type(12)
                        if True:
                            literal_1 = self.expect_type(8)
                            if literal_1:
                                literal_2 = self.expect_type(11)
                                if literal_2:
                                    _newline = self.expect_type(4)
                                    if _newline:
                                        
                                        if self.negative_lookahead(self.expect_type, 5):
                                            return self . raise_indentation_error ( "expected an indented block after 'with' statement on line %s" % a . lineno )
        self._reset(mark)
        return None

    @logger
    def invalid_try_stmt(self): # type Optional[NoReturn]
        # invalid_try_stmt: 'try' ':' NEWLINE !INDENT | 'try' ':' block !('except' | 'finally')
        mark = self._mark()
        a = self.expect_type(510)
        if a:
            literal = self.expect_type(11)
            if literal:
                _newline = self.expect_type(4)
                if _newline:
                    
                    if self.negative_lookahead(self.expect_type, 5):
                        return self . raise_indentation_error ( "expected an indented block after 'try' statement on line %s" % a . lineno )
        self._reset(mark)
        literal = self.expect_type(510)
        if literal:
            literal_1 = self.expect_type(11)
            if literal_1:
                block = self.block()
                if block:
                    
                    if self.negative_lookahead(self._tmp_171, ):
                        return self . raise_syntax_error ( "expected 'except' or 'finally' block" )
        self._reset(mark)
        return None

    @logger
    def invalid_except_stmt(self): # type Optional[None]
        # invalid_except_stmt: 'except' expression ',' expressions ['as' NAME] ':' | 'except' expression ['as' NAME] NEWLINE | 'except' NEWLINE
        mark = self._mark()
        literal = self.expect_type(522)
        if literal:
            a = self.expression()
            if a:
                literal_1 = self.expect_type(12)
                if literal_1:
                    expressions = self.expressions()
                    if expressions:
                        opt = self._tmp_172()
                        if True:
                            literal_2 = self.expect_type(11)
                            if literal_2:
                                return self . raise_syntax_error_starting_from ( "exception group must be parenthesized" , a )
        self._reset(mark)
        a = self.expect_type(522)
        if a:
            expression = self.expression()
            if expression:
                opt = self._tmp_173()
                if True:
                    _newline = self.expect_type(4)
                    if _newline:
                        return self . raise_syntax_error ( "expected ':'" )
        self._reset(mark)
        a = self.expect_type(522)
        if a:
            _newline = self.expect_type(4)
            if _newline:
                return self . raise_syntax_error ( "expected ':'" )
        self._reset(mark)
        return None

    @logger
    def invalid_finally_stmt(self): # type Optional[NoReturn]
        # invalid_finally_stmt: 'finally' ':' NEWLINE !INDENT
        mark = self._mark()
        a = self.expect_type(523)
        if a:
            literal = self.expect_type(11)
            if literal:
                _newline = self.expect_type(4)
                if _newline:
                    
                    if self.negative_lookahead(self.expect_type, 5):
                        return self . raise_indentation_error ( "expected an indented block after 'finally' statement on line %s" % a . lineno )
        self._reset(mark)
        return None

    @logger
    def invalid_except_stmt_indent(self): # type Optional[NoReturn]
        # invalid_except_stmt_indent: 'except' expression ['as' NAME] ':' NEWLINE !INDENT | 'except' ':' NEWLINE !INDENT
        mark = self._mark()
        a = self.expect_type(522)
        if a:
            expression = self.expression()
            if expression:
                opt = self._tmp_174()
                if True:
                    literal = self.expect_type(11)
                    if literal:
                        _newline = self.expect_type(4)
                        if _newline:
                            
                            if self.negative_lookahead(self.expect_type, 5):
                                return self . raise_indentation_error ( "expected an indented block after 'except' statement on line %s" % a . lineno )
        self._reset(mark)
        a = self.expect_type(522)
        if a:
            literal = self.expect_type(11)
            if literal:
                _newline = self.expect_type(4)
                if _newline:
                    
                    if self.negative_lookahead(self.expect_type, 5):
                        return self . raise_indentation_error ( "expected an indented block after 'except' statement on line %s" % a . lineno )
        self._reset(mark)
        return None

    @logger
    def invalid_match_stmt(self): # type Optional[NoReturn]
        # invalid_match_stmt: "match" subject_expr !':' | "match" subject_expr ':' NEWLINE !INDENT
        mark = self._mark()
        literal = self.expect("match")
        if literal:
            subject_expr = self.subject_expr()
            if subject_expr:
                
                if self.negative_lookahead(self.expect_type, 11):
                    return self . check_version ( ( 3 , 10 ) , "Pattern matching is" , self . raise_syntax_error ( "expected ':'" ) )
        self._reset(mark)
        a = self.expect("match")
        if a:
            subject = self.subject_expr()
            if subject:
                literal = self.expect_type(11)
                if literal:
                    _newline = self.expect_type(4)
                    if _newline:
                        
                        if self.negative_lookahead(self.expect_type, 5):
                            return self . check_version ( ( 3 , 10 ) , "Pattern matching is" , self . raise_indentation_error ( "expected an indented block after 'match' statement on line %s" % a . lineno ) )
        self._reset(mark)
        return None

    @logger
    def invalid_case_block(self): # type Optional[NoReturn]
        # invalid_case_block: "case" patterns guard? !':' | "case" patterns guard? ':' NEWLINE !INDENT
        mark = self._mark()
        literal = self.expect("case")
        if literal:
            patterns = self.patterns()
            if patterns:
                opt = self.guard()
                if True:
                    
                    if self.negative_lookahead(self.expect_type, 11):
                        return self . raise_syntax_error ( "expected ':'" )
        self._reset(mark)
        a = self.expect("case")
        if a:
            patterns = self.patterns()
            if patterns:
                opt = self.guard()
                if True:
                    literal = self.expect_type(11)
                    if literal:
                        _newline = self.expect_type(4)
                        if _newline:
                            
                            if self.negative_lookahead(self.expect_type, 5):
                                return self . raise_indentation_error ( "expected an indented block after 'case' statement on line %s" % a . lineno )
        self._reset(mark)
        return None

    @logger
    def invalid_as_pattern(self): # type Optional[NoReturn]
        # invalid_as_pattern: or_pattern 'as' "_" | or_pattern 'as' !NAME expression
        mark = self._mark()
        or_pattern = self.or_pattern()
        if or_pattern:
            literal = self.expect_type(521)
            if literal:
                a = self.expect("_")
                if a:
                    return self . raise_syntax_error_known_location_tok ( "cannot use '_' as a target" , a )
        self._reset(mark)
        or_pattern = self.or_pattern()
        if or_pattern:
            literal = self.expect_type(521)
            if literal:
                
                if self.negative_lookahead(self.name, ):
                    a = self.expression()
                    if a:
                        return self . raise_syntax_error_known_location_ast ( "invalid pattern target" , a )
        self._reset(mark)
        return None

    @logger
    def invalid_class_pattern(self): # type Optional[NoReturn]
        # invalid_class_pattern: name_or_attr '(' invalid_class_argument_pattern
        mark = self._mark()
        name_or_attr = self.name_or_attr()
        if name_or_attr:
            literal = self.expect_type(7)
            if literal:
                a = self.invalid_class_argument_pattern()
                if a:
                    return self . raise_syntax_error_known_range ( "positional patterns follow keyword patterns" , a [0] , a [- 1] )
        self._reset(mark)
        return None

    @logger
    def invalid_class_argument_pattern(self): # type Optional[list]
        # invalid_class_argument_pattern: [positional_patterns ','] keyword_patterns ',' positional_patterns
        mark = self._mark()
        opt = self._tmp_175()
        if True:
            keyword_patterns = self.keyword_patterns()
            if keyword_patterns:
                literal = self.expect_type(12)
                if literal:
                    a = self.positional_patterns()
                    if a:
                        return a
        self._reset(mark)
        return None

    @logger
    def invalid_if_stmt(self): # type Optional[NoReturn]
        # invalid_if_stmt: 'if' named_expression NEWLINE | 'if' named_expression ':' NEWLINE !INDENT
        mark = self._mark()
        literal = self.expect_type(509)
        if literal:
            named_expression = self.named_expression()
            if named_expression:
                _newline = self.expect_type(4)
                if _newline:
                    return self . raise_syntax_error ( "expected ':'" )
        self._reset(mark)
        a = self.expect_type(509)
        if a:
            a_1 = self.named_expression()
            if a_1:
                literal = self.expect_type(11)
                if literal:
                    _newline = self.expect_type(4)
                    if _newline:
                        
                        if self.negative_lookahead(self.expect_type, 5):
                            return self . raise_indentation_error ( "expected an indented block after 'if' statement on line %s" % a . lineno )
        self._reset(mark)
        return None

    @logger
    def invalid_elif_stmt(self): # type Optional[NoReturn]
        # invalid_elif_stmt: 'elif' named_expression NEWLINE | 'elif' named_expression ':' NEWLINE !INDENT
        mark = self._mark()
        literal = self.expect_type(516)
        if literal:
            named_expression = self.named_expression()
            if named_expression:
                _newline = self.expect_type(4)
                if _newline:
                    return self . raise_syntax_error ( "expected ':'" )
        self._reset(mark)
        a = self.expect_type(516)
        if a:
            named_expression = self.named_expression()
            if named_expression:
                literal = self.expect_type(11)
                if literal:
                    _newline = self.expect_type(4)
                    if _newline:
                        
                        if self.negative_lookahead(self.expect_type, 5):
                            return self . raise_indentation_error ( "expected an indented block after 'elif' statement on line %s" % a . lineno )
        self._reset(mark)
        return None

    @logger
    def invalid_else_stmt(self): # type Optional[NoReturn]
        # invalid_else_stmt: 'else' ':' NEWLINE !INDENT
        mark = self._mark()
        a = self.expect_type(517)
        if a:
            literal = self.expect_type(11)
            if literal:
                _newline = self.expect_type(4)
                if _newline:
                    
                    if self.negative_lookahead(self.expect_type, 5):
                        return self . raise_indentation_error ( "expected an indented block after 'else' statement on line %s" % a . lineno )
        self._reset(mark)
        return None

    @logger
    def invalid_while_stmt(self): # type Optional[NoReturn]
        # invalid_while_stmt: 'while' named_expression NEWLINE | 'while' named_expression ':' NEWLINE !INDENT
        mark = self._mark()
        literal = self.expect_type(511)
        if literal:
            named_expression = self.named_expression()
            if named_expression:
                _newline = self.expect_type(4)
                if _newline:
                    return self . raise_syntax_error ( "expected ':'" )
        self._reset(mark)
        a = self.expect_type(511)
        if a:
            named_expression = self.named_expression()
            if named_expression:
                literal = self.expect_type(11)
                if literal:
                    _newline = self.expect_type(4)
                    if _newline:
                        
                        if self.negative_lookahead(self.expect_type, 5):
                            return self . raise_indentation_error ( "expected an indented block after 'while' statement on line %s" % a . lineno )
        self._reset(mark)
        return None

    @logger
    def invalid_for_stmt(self): # type Optional[NoReturn]
        # invalid_for_stmt: ASYNC? 'for' star_targets 'in' star_expressions ':' NEWLINE !INDENT
        mark = self._mark()
        opt = self.expect_type(58)
        if True:
            a = self.expect_type(518)
            if a:
                star_targets = self.star_targets()
                if star_targets:
                    literal = self.expect_type(519)
                    if literal:
                        star_expressions = self.star_expressions()
                        if star_expressions:
                            literal_1 = self.expect_type(11)
                            if literal_1:
                                _newline = self.expect_type(4)
                                if _newline:
                                    
                                    if self.negative_lookahead(self.expect_type, 5):
                                        return self . raise_indentation_error ( "expected an indented block after 'for' statement on line %s" % a . lineno )
        self._reset(mark)
        return None

    @logger
    def invalid_def_raw(self): # type Optional[NoReturn]
        # invalid_def_raw: ASYNC? 'def' NAME '(' params? ')' ['->' expression] ':' NEWLINE !INDENT
        mark = self._mark()
        opt = self.expect_type(58)
        if True:
            a = self.expect_type(515)
            if a:
                name = self.name()
                if name:
                    literal = self.expect_type(7)
                    if literal:
                        opt_1 = self.params()
                        if True:
                            literal_1 = self.expect_type(8)
                            if literal_1:
                                opt_2 = self._tmp_176()
                                if True:
                                    literal_2 = self.expect_type(11)
                                    if literal_2:
                                        _newline = self.expect_type(4)
                                        if _newline:
                                            
                                            if self.negative_lookahead(self.expect_type, 5):
                                                return self . raise_indentation_error ( "expected an indented block after function definition on line %s" % a . lineno )
        self._reset(mark)
        return None

    @logger
    def invalid_class_def_raw(self): # type Optional[NoReturn]
        # invalid_class_def_raw: 'class' NAME ['(' arguments? ')'] ':' NEWLINE !INDENT
        mark = self._mark()
        a = self.expect_type(514)
        if a:
            name = self.name()
            if name:
                opt = self._tmp_177()
                if True:
                    literal = self.expect_type(11)
                    if literal:
                        _newline = self.expect_type(4)
                        if _newline:
                            
                            if self.negative_lookahead(self.expect_type, 5):
                                return self . raise_indentation_error ( "expected an indented block after class definition on line %s" % a . lineno )
        self._reset(mark)
        return None

    @logger
    def invalid_double_starred_kvpairs(self): # type Optional[None]
        # invalid_double_starred_kvpairs: ','.double_starred_kvpair+ ',' invalid_kvpair | expression ':' '*' bitwise_or | expression ':' &('}' | ',')
        mark = self._mark()
        _gather_178 = self._gather_178()
        if _gather_178:
            literal = self.expect_type(12)
            if literal:
                invalid_kvpair = self.invalid_kvpair()
                if invalid_kvpair:
                    return None  # pragma: no cover
        self._reset(mark)
        expression = self.expression()
        if expression:
            literal = self.expect_type(11)
            if literal:
                a = self.expect_type(16)
                if a:
                    bitwise_or = self.bitwise_or()
                    if bitwise_or:
                        return self . raise_syntax_error_starting_from ( "cannot use a starred expression in a dictionary value" , a )
        self._reset(mark)
        expression = self.expression()
        if expression:
            a = self.expect_type(11)
            if a:
                
                if self.positive_lookahead(self._tmp_180, ):
                    return self . raise_syntax_error_known_location_tok ( "expression expected after dictionary key and ':'" , a )
        self._reset(mark)
        return None

    @logger
    def invalid_kvpair(self): # type Optional[None]
        # invalid_kvpair: expression !(':') | expression ':' '*' bitwise_or | expression ':'
        mark = self._mark()
        a = self.expression()
        if a:
            
            if self.negative_lookahead(self.expect_type, 11):
                return self . _raise_syntax_error ( "':' expected after dictionary key" , ( a . lineno , a . col_offset - 1 ) , ( a . end_lineno , a . end_col_offset , - 1 ) )
        self._reset(mark)
        expression = self.expression()
        if expression:
            literal = self.expect_type(11)
            if literal:
                a = self.expect_type(16)
                if a:
                    bitwise_or = self.bitwise_or()
                    if bitwise_or:
                        return self . raise_syntax_error_starting_from ( "cannot use a starred expression in a dictionary value" , a )
        self._reset(mark)
        expression = self.expression()
        if expression:
            a = self.expect_type(11)
            if a:
                return self . raise_syntax_error_known_location_tok ( "expression expected after dictionary key and ':'" , a )
        self._reset(mark)
        return None

    @logger
    def _loop0_1(self): # type Optional[Any]
        # _loop0_1: NEWLINE
        mark = self._mark()
        children = []
        while True:
            _newline = self.expect_type(4)
            if not _newline:
                break
            children.append(_newline)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_2(self): # type Optional[Any]
        # _loop0_2: NEWLINE
        mark = self._mark()
        children = []
        while True:
            _newline = self.expect_type(4)
            if not _newline:
                break
            children.append(_newline)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_3(self): # type Optional[Any]
        # _loop1_3: statement
        mark = self._mark()
        children = []
        while True:
            statement = self.statement()
            if not statement:
                break
            children.append(statement)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_5(self): # type Optional[Any]
        # _loop0_5: ';' simple_stmt
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(13)
            if not literal:
                break
            elem = self.simple_stmt()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_4(self): # type Optional[Any]
        # _gather_4: simple_stmt _loop0_5
        mark = self._mark()
        elem = self.simple_stmt()
        if elem is not None:
            seq = self._loop0_5()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _tmp_6(self): # type Optional[Any]
        # _tmp_6: 'import' | 'from'
        mark = self._mark()
        literal = self.expect_type(512)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(513)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _tmp_7(self): # type Optional[Any]
        # _tmp_7: 'def' | '@' | ASYNC
        mark = self._mark()
        literal = self.expect_type(515)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(50)
        if literal:
            return literal
        self._reset(mark)
        _async = self.expect_type(58)
        if _async:
            return _async
        self._reset(mark)
        return None

    @logger
    def _tmp_8(self): # type Optional[Any]
        # _tmp_8: 'class' | '@'
        mark = self._mark()
        literal = self.expect_type(514)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(50)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _tmp_9(self): # type Optional[Any]
        # _tmp_9: 'with' | ASYNC
        mark = self._mark()
        literal = self.expect_type(520)
        if literal:
            return literal
        self._reset(mark)
        _async = self.expect_type(58)
        if _async:
            return _async
        self._reset(mark)
        return None

    @logger
    def _tmp_10(self): # type Optional[Any]
        # _tmp_10: 'for' | ASYNC
        mark = self._mark()
        literal = self.expect_type(518)
        if literal:
            return literal
        self._reset(mark)
        _async = self.expect_type(58)
        if _async:
            return _async
        self._reset(mark)
        return None

    @logger
    def _tmp_11(self): # type Optional[Any]
        # _tmp_11: '=' annotated_rhs
        mark = self._mark()
        literal = self.expect_type(22)
        if literal:
            d = self.annotated_rhs()
            if d:
                return d
        self._reset(mark)
        return None

    @logger
    def _tmp_12(self): # type Optional[Any]
        # _tmp_12: '(' single_target ')' | single_subscript_attribute_target
        mark = self._mark()
        literal = self.expect_type(7)
        if literal:
            b = self.single_target()
            if b:
                literal_1 = self.expect_type(8)
                if literal_1:
                    return b
        self._reset(mark)
        single_subscript_attribute_target = self.single_subscript_attribute_target()
        if single_subscript_attribute_target:
            return single_subscript_attribute_target
        self._reset(mark)
        return None

    @logger
    def _tmp_13(self): # type Optional[Any]
        # _tmp_13: '=' annotated_rhs
        mark = self._mark()
        literal = self.expect_type(22)
        if literal:
            d = self.annotated_rhs()
            if d:
                return d
        self._reset(mark)
        return None

    @logger
    def _loop1_14(self): # type Optional[Any]
        # _loop1_14: (star_targets '=')
        mark = self._mark()
        children = []
        while True:
            _tmp_181 = self._tmp_181()
            if not _tmp_181:
                break
            children.append(_tmp_181)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _tmp_15(self): # type Optional[Any]
        # _tmp_15: yield_expr | star_expressions
        mark = self._mark()
        yield_expr = self.yield_expr()
        if yield_expr:
            return yield_expr
        self._reset(mark)
        star_expressions = self.star_expressions()
        if star_expressions:
            return star_expressions
        self._reset(mark)
        return None

    @logger
    def _tmp_16(self): # type Optional[Any]
        # _tmp_16: yield_expr | star_expressions
        mark = self._mark()
        yield_expr = self.yield_expr()
        if yield_expr:
            return yield_expr
        self._reset(mark)
        star_expressions = self.star_expressions()
        if star_expressions:
            return star_expressions
        self._reset(mark)
        return None

    @logger
    def _tmp_17(self): # type Optional[Any]
        # _tmp_17: 'from' expression
        mark = self._mark()
        literal = self.expect_type(513)
        if literal:
            z = self.expression()
            if z:
                return z
        self._reset(mark)
        return None

    @logger
    def _loop0_19(self): # type Optional[Any]
        # _loop0_19: ',' NAME
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.name()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_18(self): # type Optional[Any]
        # _gather_18: NAME _loop0_19
        mark = self._mark()
        elem = self.name()
        if elem is not None:
            seq = self._loop0_19()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop0_21(self): # type Optional[Any]
        # _loop0_21: ',' NAME
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.name()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_20(self): # type Optional[Any]
        # _gather_20: NAME _loop0_21
        mark = self._mark()
        elem = self.name()
        if elem is not None:
            seq = self._loop0_21()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _tmp_22(self): # type Optional[Any]
        # _tmp_22: ';' | NEWLINE
        mark = self._mark()
        literal = self.expect_type(13)
        if literal:
            return literal
        self._reset(mark)
        _newline = self.expect_type(4)
        if _newline:
            return _newline
        self._reset(mark)
        return None

    @logger
    def _tmp_23(self): # type Optional[Any]
        # _tmp_23: ',' expression
        mark = self._mark()
        literal = self.expect_type(12)
        if literal:
            z = self.expression()
            if z:
                return z
        self._reset(mark)
        return None

    @logger
    def _loop0_24(self): # type Optional[Any]
        # _loop0_24: ('.' | '...')
        mark = self._mark()
        children = []
        while True:
            _tmp_182 = self._tmp_182()
            if not _tmp_182:
                break
            children.append(_tmp_182)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_25(self): # type Optional[Any]
        # _loop1_25: ('.' | '...')
        mark = self._mark()
        children = []
        while True:
            _tmp_183 = self._tmp_183()
            if not _tmp_183:
                break
            children.append(_tmp_183)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_27(self): # type Optional[Any]
        # _loop0_27: ',' import_from_as_name
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.import_from_as_name()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_26(self): # type Optional[Any]
        # _gather_26: import_from_as_name _loop0_27
        mark = self._mark()
        elem = self.import_from_as_name()
        if elem is not None:
            seq = self._loop0_27()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _tmp_28(self): # type Optional[Any]
        # _tmp_28: 'as' NAME
        mark = self._mark()
        literal = self.expect_type(521)
        if literal:
            z = self.name()
            if z:
                return z
        self._reset(mark)
        return None

    @logger
    def _loop0_30(self): # type Optional[Any]
        # _loop0_30: ',' dotted_as_name
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.dotted_as_name()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_29(self): # type Optional[Any]
        # _gather_29: dotted_as_name _loop0_30
        mark = self._mark()
        elem = self.dotted_as_name()
        if elem is not None:
            seq = self._loop0_30()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _tmp_31(self): # type Optional[Any]
        # _tmp_31: 'as' NAME
        mark = self._mark()
        literal = self.expect_type(521)
        if literal:
            z = self.name()
            if z:
                return z
        self._reset(mark)
        return None

    @logger
    def _loop1_32(self): # type Optional[Any]
        # _loop1_32: decorator
        mark = self._mark()
        children = []
        while True:
            decorator = self.decorator()
            if not decorator:
                break
            children.append(decorator)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _tmp_33(self): # type Optional[Any]
        # _tmp_33: '@' dec_maybe_call NEWLINE
        mark = self._mark()
        literal = self.expect_type(50)
        if literal:
            f = self.dec_maybe_call()
            if f:
                _newline = self.expect_type(4)
                if _newline:
                    return f
        self._reset(mark)
        return None

    @logger
    def _tmp_34(self): # type Optional[Any]
        # _tmp_34: '@' named_expression NEWLINE
        mark = self._mark()
        literal = self.expect_type(50)
        if literal:
            f = self.named_expression()
            if f:
                _newline = self.expect_type(4)
                if _newline:
                    return f
        self._reset(mark)
        return None

    @logger
    def _tmp_35(self): # type Optional[Any]
        # _tmp_35: '(' arguments? ')'
        mark = self._mark()
        literal = self.expect_type(7)
        if literal:
            z = self.arguments()
            if True:
                literal_1 = self.expect_type(8)
                if literal_1:
                    return z
        self._reset(mark)
        return None

    @logger
    def _tmp_36(self): # type Optional[Any]
        # _tmp_36: '->' expression
        mark = self._mark()
        literal = self.expect_type(52)
        if literal:
            z = self.expression()
            if z:
                return z
        self._reset(mark)
        return None

    @logger
    def _tmp_37(self): # type Optional[Any]
        # _tmp_37: '->' expression
        mark = self._mark()
        literal = self.expect_type(52)
        if literal:
            z = self.expression()
            if z:
                return z
        self._reset(mark)
        return None

    @logger
    def _loop0_38(self): # type Optional[Any]
        # _loop0_38: param_no_default
        mark = self._mark()
        children = []
        while True:
            param_no_default = self.param_no_default()
            if not param_no_default:
                break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_39(self): # type Optional[Any]
        # _loop0_39: param_with_default
        mark = self._mark()
        children = []
        while True:
            param_with_default = self.param_with_default()
            if not param_with_default:
                break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_40(self): # type Optional[Any]
        # _loop0_40: param_with_default
        mark = self._mark()
        children = []
        while True:
            param_with_default = self.param_with_default()
            if not param_with_default:
                break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_41(self): # type Optional[Any]
        # _loop1_41: param_no_default
        mark = self._mark()
        children = []
        while True:
            param_no_default = self.param_no_default()
            if not param_no_default:
                break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_42(self): # type Optional[Any]
        # _loop0_42: param_with_default
        mark = self._mark()
        children = []
        while True:
            param_with_default = self.param_with_default()
            if not param_with_default:
                break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_43(self): # type Optional[Any]
        # _loop1_43: param_with_default
        mark = self._mark()
        children = []
        while True:
            param_with_default = self.param_with_default()
            if not param_with_default:
                break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_44(self): # type Optional[Any]
        # _loop1_44: param_no_default
        mark = self._mark()
        children = []
        while True:
            param_no_default = self.param_no_default()
            if not param_no_default:
                break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_45(self): # type Optional[Any]
        # _loop1_45: param_no_default
        mark = self._mark()
        children = []
        while True:
            param_no_default = self.param_no_default()
            if not param_no_default:
                break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_46(self): # type Optional[Any]
        # _loop0_46: param_no_default
        mark = self._mark()
        children = []
        while True:
            param_no_default = self.param_no_default()
            if not param_no_default:
                break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_47(self): # type Optional[Any]
        # _loop1_47: param_with_default
        mark = self._mark()
        children = []
        while True:
            param_with_default = self.param_with_default()
            if not param_with_default:
                break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_48(self): # type Optional[Any]
        # _loop0_48: param_no_default
        mark = self._mark()
        children = []
        while True:
            param_no_default = self.param_no_default()
            if not param_no_default:
                break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_49(self): # type Optional[Any]
        # _loop1_49: param_with_default
        mark = self._mark()
        children = []
        while True:
            param_with_default = self.param_with_default()
            if not param_with_default:
                break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_50(self): # type Optional[Any]
        # _loop0_50: param_maybe_default
        mark = self._mark()
        children = []
        while True:
            param_maybe_default = self.param_maybe_default()
            if not param_maybe_default:
                break
            children.append(param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_51(self): # type Optional[Any]
        # _loop1_51: param_maybe_default
        mark = self._mark()
        children = []
        while True:
            param_maybe_default = self.param_maybe_default()
            if not param_maybe_default:
                break
            children.append(param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_53(self): # type Optional[Any]
        # _loop0_53: ',' with_item
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.with_item()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_52(self): # type Optional[Any]
        # _gather_52: with_item _loop0_53
        mark = self._mark()
        elem = self.with_item()
        if elem is not None:
            seq = self._loop0_53()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop0_55(self): # type Optional[Any]
        # _loop0_55: ',' with_item
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.with_item()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_54(self): # type Optional[Any]
        # _gather_54: with_item _loop0_55
        mark = self._mark()
        elem = self.with_item()
        if elem is not None:
            seq = self._loop0_55()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop0_57(self): # type Optional[Any]
        # _loop0_57: ',' with_item
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.with_item()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_56(self): # type Optional[Any]
        # _gather_56: with_item _loop0_57
        mark = self._mark()
        elem = self.with_item()
        if elem is not None:
            seq = self._loop0_57()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop0_59(self): # type Optional[Any]
        # _loop0_59: ',' with_item
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.with_item()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_58(self): # type Optional[Any]
        # _gather_58: with_item _loop0_59
        mark = self._mark()
        elem = self.with_item()
        if elem is not None:
            seq = self._loop0_59()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _tmp_60(self): # type Optional[Any]
        # _tmp_60: ',' | ')' | ':'
        mark = self._mark()
        literal = self.expect_type(12)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(8)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(11)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _loop1_61(self): # type Optional[Any]
        # _loop1_61: except_block
        mark = self._mark()
        children = []
        while True:
            except_block = self.except_block()
            if not except_block:
                break
            children.append(except_block)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _tmp_62(self): # type Optional[Any]
        # _tmp_62: 'as' NAME
        mark = self._mark()
        literal = self.expect_type(521)
        if literal:
            z = self.name()
            if z:
                return z
        self._reset(mark)
        return None

    @logger
    def _loop1_63(self): # type Optional[Any]
        # _loop1_63: case_block
        mark = self._mark()
        children = []
        while True:
            case_block = self.case_block()
            if not case_block:
                break
            children.append(case_block)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_65(self): # type Optional[Any]
        # _loop0_65: '|' closed_pattern
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(18)
            if not literal:
                break
            elem = self.closed_pattern()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_64(self): # type Optional[Any]
        # _gather_64: closed_pattern _loop0_65
        mark = self._mark()
        elem = self.closed_pattern()
        if elem is not None:
            seq = self._loop0_65()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _tmp_66(self): # type Optional[Any]
        # _tmp_66: '+' | '-'
        mark = self._mark()
        literal = self.expect_type(14)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(15)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _tmp_67(self): # type Optional[Any]
        # _tmp_67: '+' | '-'
        mark = self._mark()
        literal = self.expect_type(14)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(15)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _tmp_68(self): # type Optional[Any]
        # _tmp_68: '.' | '(' | '='
        mark = self._mark()
        literal = self.expect_type(23)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(7)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(22)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _tmp_69(self): # type Optional[Any]
        # _tmp_69: '.' | '(' | '='
        mark = self._mark()
        literal = self.expect_type(23)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(7)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(22)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _loop0_71(self): # type Optional[Any]
        # _loop0_71: ',' maybe_star_pattern
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.maybe_star_pattern()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_70(self): # type Optional[Any]
        # _gather_70: maybe_star_pattern _loop0_71
        mark = self._mark()
        elem = self.maybe_star_pattern()
        if elem is not None:
            seq = self._loop0_71()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop0_73(self): # type Optional[Any]
        # _loop0_73: ',' key_value_pattern
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.key_value_pattern()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_72(self): # type Optional[Any]
        # _gather_72: key_value_pattern _loop0_73
        mark = self._mark()
        elem = self.key_value_pattern()
        if elem is not None:
            seq = self._loop0_73()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _tmp_74(self): # type Optional[Any]
        # _tmp_74: literal_expr | attr
        mark = self._mark()
        literal_expr = self.literal_expr()
        if literal_expr:
            return literal_expr
        self._reset(mark)
        attr = self.attr()
        if attr:
            return attr
        self._reset(mark)
        return None

    @logger
    def _loop0_76(self): # type Optional[Any]
        # _loop0_76: ',' pattern
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.pattern()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_75(self): # type Optional[Any]
        # _gather_75: pattern _loop0_76
        mark = self._mark()
        elem = self.pattern()
        if elem is not None:
            seq = self._loop0_76()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop0_78(self): # type Optional[Any]
        # _loop0_78: ',' keyword_pattern
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.keyword_pattern()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_77(self): # type Optional[Any]
        # _gather_77: keyword_pattern _loop0_78
        mark = self._mark()
        elem = self.keyword_pattern()
        if elem is not None:
            seq = self._loop0_78()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop1_79(self): # type Optional[Any]
        # _loop1_79: (',' expression)
        mark = self._mark()
        children = []
        while True:
            _tmp_184 = self._tmp_184()
            if not _tmp_184:
                break
            children.append(_tmp_184)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_80(self): # type Optional[Any]
        # _loop1_80: (',' star_expression)
        mark = self._mark()
        children = []
        while True:
            _tmp_185 = self._tmp_185()
            if not _tmp_185:
                break
            children.append(_tmp_185)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_82(self): # type Optional[Any]
        # _loop0_82: ',' star_named_expression
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.star_named_expression()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_81(self): # type Optional[Any]
        # _gather_81: star_named_expression _loop0_82
        mark = self._mark()
        elem = self.star_named_expression()
        if elem is not None:
            seq = self._loop0_82()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop1_83(self): # type Optional[Any]
        # _loop1_83: ('or' conjunction)
        mark = self._mark()
        children = []
        while True:
            _tmp_186 = self._tmp_186()
            if not _tmp_186:
                break
            children.append(_tmp_186)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_84(self): # type Optional[Any]
        # _loop1_84: ('and' inversion)
        mark = self._mark()
        children = []
        while True:
            _tmp_187 = self._tmp_187()
            if not _tmp_187:
                break
            children.append(_tmp_187)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_85(self): # type Optional[Any]
        # _loop1_85: compare_op_bitwise_or_pair
        mark = self._mark()
        children = []
        while True:
            compare_op_bitwise_or_pair = self.compare_op_bitwise_or_pair()
            if not compare_op_bitwise_or_pair:
                break
            children.append(compare_op_bitwise_or_pair)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_87(self): # type Optional[Any]
        # _loop0_87: ',' slice
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.slice()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_86(self): # type Optional[Any]
        # _gather_86: slice _loop0_87
        mark = self._mark()
        elem = self.slice()
        if elem is not None:
            seq = self._loop0_87()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _tmp_88(self): # type Optional[Any]
        # _tmp_88: ':' expression?
        mark = self._mark()
        literal = self.expect_type(11)
        if literal:
            d = self.expression()
            if True:
                return d
        self._reset(mark)
        return None

    @logger
    def _tmp_89(self): # type Optional[Any]
        # _tmp_89: tuple | group | genexp
        mark = self._mark()
        tuple = self.tuple()
        if tuple:
            return tuple
        self._reset(mark)
        group = self.group()
        if group:
            return group
        self._reset(mark)
        genexp = self.genexp()
        if genexp:
            return genexp
        self._reset(mark)
        return None

    @logger
    def _tmp_90(self): # type Optional[Any]
        # _tmp_90: list | listcomp
        mark = self._mark()
        list = self.list()
        if list:
            return list
        self._reset(mark)
        listcomp = self.listcomp()
        if listcomp:
            return listcomp
        self._reset(mark)
        return None

    @logger
    def _tmp_91(self): # type Optional[Any]
        # _tmp_91: dict | set | dictcomp | setcomp
        mark = self._mark()
        dict = self.dict()
        if dict:
            return dict
        self._reset(mark)
        set = self.set()
        if set:
            return set
        self._reset(mark)
        dictcomp = self.dictcomp()
        if dictcomp:
            return dictcomp
        self._reset(mark)
        setcomp = self.setcomp()
        if setcomp:
            return setcomp
        self._reset(mark)
        return None

    @logger
    def _tmp_92(self): # type Optional[Any]
        # _tmp_92: yield_expr | named_expression
        mark = self._mark()
        yield_expr = self.yield_expr()
        if yield_expr:
            return yield_expr
        self._reset(mark)
        named_expression = self.named_expression()
        if named_expression:
            return named_expression
        self._reset(mark)
        return None

    @logger
    def _loop0_93(self): # type Optional[Any]
        # _loop0_93: lambda_param_no_default
        mark = self._mark()
        children = []
        while True:
            lambda_param_no_default = self.lambda_param_no_default()
            if not lambda_param_no_default:
                break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_94(self): # type Optional[Any]
        # _loop0_94: lambda_param_with_default
        mark = self._mark()
        children = []
        while True:
            lambda_param_with_default = self.lambda_param_with_default()
            if not lambda_param_with_default:
                break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_95(self): # type Optional[Any]
        # _loop0_95: lambda_param_with_default
        mark = self._mark()
        children = []
        while True:
            lambda_param_with_default = self.lambda_param_with_default()
            if not lambda_param_with_default:
                break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_96(self): # type Optional[Any]
        # _loop1_96: lambda_param_no_default
        mark = self._mark()
        children = []
        while True:
            lambda_param_no_default = self.lambda_param_no_default()
            if not lambda_param_no_default:
                break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_97(self): # type Optional[Any]
        # _loop0_97: lambda_param_with_default
        mark = self._mark()
        children = []
        while True:
            lambda_param_with_default = self.lambda_param_with_default()
            if not lambda_param_with_default:
                break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_98(self): # type Optional[Any]
        # _loop1_98: lambda_param_with_default
        mark = self._mark()
        children = []
        while True:
            lambda_param_with_default = self.lambda_param_with_default()
            if not lambda_param_with_default:
                break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_99(self): # type Optional[Any]
        # _loop1_99: lambda_param_no_default
        mark = self._mark()
        children = []
        while True:
            lambda_param_no_default = self.lambda_param_no_default()
            if not lambda_param_no_default:
                break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_100(self): # type Optional[Any]
        # _loop1_100: lambda_param_no_default
        mark = self._mark()
        children = []
        while True:
            lambda_param_no_default = self.lambda_param_no_default()
            if not lambda_param_no_default:
                break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_101(self): # type Optional[Any]
        # _loop0_101: lambda_param_no_default
        mark = self._mark()
        children = []
        while True:
            lambda_param_no_default = self.lambda_param_no_default()
            if not lambda_param_no_default:
                break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_102(self): # type Optional[Any]
        # _loop1_102: lambda_param_with_default
        mark = self._mark()
        children = []
        while True:
            lambda_param_with_default = self.lambda_param_with_default()
            if not lambda_param_with_default:
                break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_103(self): # type Optional[Any]
        # _loop0_103: lambda_param_no_default
        mark = self._mark()
        children = []
        while True:
            lambda_param_no_default = self.lambda_param_no_default()
            if not lambda_param_no_default:
                break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_104(self): # type Optional[Any]
        # _loop1_104: lambda_param_with_default
        mark = self._mark()
        children = []
        while True:
            lambda_param_with_default = self.lambda_param_with_default()
            if not lambda_param_with_default:
                break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_105(self): # type Optional[Any]
        # _loop0_105: lambda_param_maybe_default
        mark = self._mark()
        children = []
        while True:
            lambda_param_maybe_default = self.lambda_param_maybe_default()
            if not lambda_param_maybe_default:
                break
            children.append(lambda_param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_106(self): # type Optional[Any]
        # _loop1_106: lambda_param_maybe_default
        mark = self._mark()
        children = []
        while True:
            lambda_param_maybe_default = self.lambda_param_maybe_default()
            if not lambda_param_maybe_default:
                break
            children.append(lambda_param_maybe_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_107(self): # type Optional[Any]
        # _loop1_107: STRING
        mark = self._mark()
        children = []
        while True:
            string = self.string()
            if not string:
                break
            children.append(string)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _tmp_108(self): # type Optional[Any]
        # _tmp_108: star_named_expression ',' star_named_expressions?
        mark = self._mark()
        y = self.star_named_expression()
        if y:
            literal = self.expect_type(12)
            if literal:
                z = self.star_named_expressions()
                if True:
                    return [y] + ( z or [] )
        self._reset(mark)
        return None

    @logger
    def _loop0_110(self): # type Optional[Any]
        # _loop0_110: ',' double_starred_kvpair
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.double_starred_kvpair()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_109(self): # type Optional[Any]
        # _gather_109: double_starred_kvpair _loop0_110
        mark = self._mark()
        elem = self.double_starred_kvpair()
        if elem is not None:
            seq = self._loop0_110()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop1_111(self): # type Optional[Any]
        # _loop1_111: for_if_clause
        mark = self._mark()
        children = []
        while True:
            for_if_clause = self.for_if_clause()
            if not for_if_clause:
                break
            children.append(for_if_clause)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_112(self): # type Optional[Any]
        # _loop0_112: ('if' disjunction)
        mark = self._mark()
        children = []
        while True:
            _tmp_188 = self._tmp_188()
            if not _tmp_188:
                break
            children.append(_tmp_188)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_113(self): # type Optional[Any]
        # _loop0_113: ('if' disjunction)
        mark = self._mark()
        children = []
        while True:
            _tmp_189 = self._tmp_189()
            if not _tmp_189:
                break
            children.append(_tmp_189)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _tmp_114(self): # type Optional[Any]
        # _tmp_114: assignment_expression | expression !':='
        mark = self._mark()
        assignment_expression = self.assignment_expression()
        if assignment_expression:
            return assignment_expression
        self._reset(mark)
        expression = self.expression()
        if expression:
            
            if self.negative_lookahead(self.expect_type, 54):
                return expression
        self._reset(mark)
        return None

    @logger
    def _loop0_116(self): # type Optional[Any]
        # _loop0_116: ',' (starred_expression | (assignment_expression | expression !':=') !'=')
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self._tmp_190()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_115(self): # type Optional[Any]
        # _gather_115: (starred_expression | (assignment_expression | expression !':=') !'=') _loop0_116
        mark = self._mark()
        elem = self._tmp_190()
        if elem is not None:
            seq = self._loop0_116()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _tmp_117(self): # type Optional[Any]
        # _tmp_117: ',' kwargs
        mark = self._mark()
        literal = self.expect_type(12)
        if literal:
            k = self.kwargs()
            if k:
                return k
        self._reset(mark)
        return None

    @logger
    def _loop0_119(self): # type Optional[Any]
        # _loop0_119: ',' kwarg_or_starred
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.kwarg_or_starred()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_118(self): # type Optional[Any]
        # _gather_118: kwarg_or_starred _loop0_119
        mark = self._mark()
        elem = self.kwarg_or_starred()
        if elem is not None:
            seq = self._loop0_119()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop0_121(self): # type Optional[Any]
        # _loop0_121: ',' kwarg_or_double_starred
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.kwarg_or_double_starred()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_120(self): # type Optional[Any]
        # _gather_120: kwarg_or_double_starred _loop0_121
        mark = self._mark()
        elem = self.kwarg_or_double_starred()
        if elem is not None:
            seq = self._loop0_121()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop0_123(self): # type Optional[Any]
        # _loop0_123: ',' kwarg_or_starred
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.kwarg_or_starred()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_122(self): # type Optional[Any]
        # _gather_122: kwarg_or_starred _loop0_123
        mark = self._mark()
        elem = self.kwarg_or_starred()
        if elem is not None:
            seq = self._loop0_123()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop0_125(self): # type Optional[Any]
        # _loop0_125: ',' kwarg_or_double_starred
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.kwarg_or_double_starred()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_124(self): # type Optional[Any]
        # _gather_124: kwarg_or_double_starred _loop0_125
        mark = self._mark()
        elem = self.kwarg_or_double_starred()
        if elem is not None:
            seq = self._loop0_125()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop0_126(self): # type Optional[Any]
        # _loop0_126: (',' star_target)
        mark = self._mark()
        children = []
        while True:
            _tmp_191 = self._tmp_191()
            if not _tmp_191:
                break
            children.append(_tmp_191)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_128(self): # type Optional[Any]
        # _loop0_128: ',' star_target
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.star_target()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_127(self): # type Optional[Any]
        # _gather_127: star_target _loop0_128
        mark = self._mark()
        elem = self.star_target()
        if elem is not None:
            seq = self._loop0_128()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop1_129(self): # type Optional[Any]
        # _loop1_129: (',' star_target)
        mark = self._mark()
        children = []
        while True:
            _tmp_192 = self._tmp_192()
            if not _tmp_192:
                break
            children.append(_tmp_192)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _tmp_130(self): # type Optional[Any]
        # _tmp_130: !'*' star_target
        mark = self._mark()
        
        if self.negative_lookahead(self.expect_type, 16):
            star_target = self.star_target()
            if star_target:
                return star_target
        self._reset(mark)
        return None

    @logger
    def _loop0_132(self): # type Optional[Any]
        # _loop0_132: ',' del_target
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.del_target()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_131(self): # type Optional[Any]
        # _gather_131: del_target _loop0_132
        mark = self._mark()
        elem = self.del_target()
        if elem is not None:
            seq = self._loop0_132()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop0_134(self): # type Optional[Any]
        # _loop0_134: ',' expression
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.expression()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_133(self): # type Optional[Any]
        # _gather_133: expression _loop0_134
        mark = self._mark()
        elem = self.expression()
        if elem is not None:
            seq = self._loop0_134()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop0_136(self): # type Optional[Any]
        # _loop0_136: ',' expression
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.expression()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_135(self): # type Optional[Any]
        # _gather_135: expression _loop0_136
        mark = self._mark()
        elem = self.expression()
        if elem is not None:
            seq = self._loop0_136()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop0_138(self): # type Optional[Any]
        # _loop0_138: ',' expression
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.expression()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_137(self): # type Optional[Any]
        # _gather_137: expression _loop0_138
        mark = self._mark()
        elem = self.expression()
        if elem is not None:
            seq = self._loop0_138()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop0_140(self): # type Optional[Any]
        # _loop0_140: ',' expression
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.expression()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_139(self): # type Optional[Any]
        # _gather_139: expression _loop0_140
        mark = self._mark()
        elem = self.expression()
        if elem is not None:
            seq = self._loop0_140()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _tmp_141(self): # type Optional[Any]
        # _tmp_141: NEWLINE INDENT
        mark = self._mark()
        _newline = self.expect_type(4)
        if _newline:
            _indent = self.expect_type(5)
            if _indent:
                return [_newline, _indent]
        self._reset(mark)
        return None

    @logger
    def _tmp_142(self): # type Optional[Any]
        # _tmp_142: args | expression for_if_clauses
        mark = self._mark()
        args = self.args()
        if args:
            return args
        self._reset(mark)
        expression = self.expression()
        if expression:
            for_if_clauses = self.for_if_clauses()
            if for_if_clauses:
                return [expression, for_if_clauses]
        self._reset(mark)
        return None

    @logger
    def _tmp_143(self): # type Optional[Any]
        # _tmp_143: NAME '='
        mark = self._mark()
        name = self.name()
        if name:
            literal = self.expect_type(22)
            if literal:
                return [name, literal]
        self._reset(mark)
        return None

    @logger
    def _tmp_144(self): # type Optional[Any]
        # _tmp_144: NAME STRING | SOFT_KEYWORD
        mark = self._mark()
        name = self.name()
        if name:
            string = self.string()
            if string:
                return [name, string]
        self._reset(mark)
        soft_keyword = self.soft_keyword()
        if soft_keyword:
            return soft_keyword
        self._reset(mark)
        return None

    @logger
    def _tmp_145(self): # type Optional[Any]
        # _tmp_145: 'else' | ':'
        mark = self._mark()
        literal = self.expect_type(517)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(11)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _tmp_146(self): # type Optional[Any]
        # _tmp_146: '=' | ':='
        mark = self._mark()
        literal = self.expect_type(22)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(54)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _tmp_147(self): # type Optional[Any]
        # _tmp_147: list | tuple | genexp | 'True' | 'None' | 'False'
        mark = self._mark()
        list = self.list()
        if list:
            return list
        self._reset(mark)
        tuple = self.tuple()
        if tuple:
            return tuple
        self._reset(mark)
        genexp = self.genexp()
        if genexp:
            return genexp
        self._reset(mark)
        literal = self.expect_type(525)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(524)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(526)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _tmp_148(self): # type Optional[Any]
        # _tmp_148: '=' | ':='
        mark = self._mark()
        literal = self.expect_type(22)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(54)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _loop0_149(self): # type Optional[Any]
        # _loop0_149: star_named_expressions
        mark = self._mark()
        children = []
        while True:
            star_named_expressions = self.star_named_expressions()
            if not star_named_expressions:
                break
            children.append(star_named_expressions)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_150(self): # type Optional[Any]
        # _loop0_150: (star_targets '=')
        mark = self._mark()
        children = []
        while True:
            _tmp_193 = self._tmp_193()
            if not _tmp_193:
                break
            children.append(_tmp_193)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_151(self): # type Optional[Any]
        # _loop0_151: (star_targets '=')
        mark = self._mark()
        children = []
        while True:
            _tmp_194 = self._tmp_194()
            if not _tmp_194:
                break
            children.append(_tmp_194)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _tmp_152(self): # type Optional[Any]
        # _tmp_152: yield_expr | star_expressions
        mark = self._mark()
        yield_expr = self.yield_expr()
        if yield_expr:
            return yield_expr
        self._reset(mark)
        star_expressions = self.star_expressions()
        if star_expressions:
            return star_expressions
        self._reset(mark)
        return None

    @logger
    def _tmp_153(self): # type Optional[Any]
        # _tmp_153: '[' | '(' | '{'
        mark = self._mark()
        literal = self.expect_type(9)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(7)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(26)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _tmp_154(self): # type Optional[Any]
        # _tmp_154: '[' | '{'
        mark = self._mark()
        literal = self.expect_type(9)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(26)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _tmp_155(self): # type Optional[Any]
        # _tmp_155: '[' | '{'
        mark = self._mark()
        literal = self.expect_type(9)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(26)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _loop0_156(self): # type Optional[Any]
        # _loop0_156: param_no_default
        mark = self._mark()
        children = []
        while True:
            param_no_default = self.param_no_default()
            if not param_no_default:
                break
            children.append(param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_157(self): # type Optional[Any]
        # _loop1_157: param_with_default
        mark = self._mark()
        children = []
        while True:
            param_with_default = self.param_with_default()
            if not param_with_default:
                break
            children.append(param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop0_158(self): # type Optional[Any]
        # _loop0_158: lambda_param_no_default
        mark = self._mark()
        children = []
        while True:
            lambda_param_no_default = self.lambda_param_no_default()
            if not lambda_param_no_default:
                break
            children.append(lambda_param_no_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _loop1_159(self): # type Optional[Any]
        # _loop1_159: lambda_param_with_default
        mark = self._mark()
        children = []
        while True:
            lambda_param_with_default = self.lambda_param_with_default()
            if not lambda_param_with_default:
                break
            children.append(lambda_param_with_default)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _tmp_160(self): # type Optional[Any]
        # _tmp_160: ')' | ',' (')' | '**')
        mark = self._mark()
        literal = self.expect_type(8)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(12)
        if literal:
            _tmp_195 = self._tmp_195()
            if _tmp_195:
                return [literal, _tmp_195]
        self._reset(mark)
        return None

    @logger
    def _tmp_161(self): # type Optional[Any]
        # _tmp_161: ':' | ',' (':' | '**')
        mark = self._mark()
        literal = self.expect_type(11)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(12)
        if literal:
            _tmp_196 = self._tmp_196()
            if _tmp_196:
                return [literal, _tmp_196]
        self._reset(mark)
        return None

    @logger
    def _tmp_162(self): # type Optional[Any]
        # _tmp_162: ',' | ')' | ':'
        mark = self._mark()
        literal = self.expect_type(12)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(8)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(11)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _loop0_164(self): # type Optional[Any]
        # _loop0_164: ',' (expression ['as' star_target])
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self._tmp_197()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_163(self): # type Optional[Any]
        # _gather_163: (expression ['as' star_target]) _loop0_164
        mark = self._mark()
        elem = self._tmp_197()
        if elem is not None:
            seq = self._loop0_164()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop0_166(self): # type Optional[Any]
        # _loop0_166: ',' (expressions ['as' star_target])
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self._tmp_198()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_165(self): # type Optional[Any]
        # _gather_165: (expressions ['as' star_target]) _loop0_166
        mark = self._mark()
        elem = self._tmp_198()
        if elem is not None:
            seq = self._loop0_166()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop0_168(self): # type Optional[Any]
        # _loop0_168: ',' (expression ['as' star_target])
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self._tmp_199()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_167(self): # type Optional[Any]
        # _gather_167: (expression ['as' star_target]) _loop0_168
        mark = self._mark()
        elem = self._tmp_199()
        if elem is not None:
            seq = self._loop0_168()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _loop0_170(self): # type Optional[Any]
        # _loop0_170: ',' (expressions ['as' star_target])
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self._tmp_200()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_169(self): # type Optional[Any]
        # _gather_169: (expressions ['as' star_target]) _loop0_170
        mark = self._mark()
        elem = self._tmp_200()
        if elem is not None:
            seq = self._loop0_170()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _tmp_171(self): # type Optional[Any]
        # _tmp_171: 'except' | 'finally'
        mark = self._mark()
        literal = self.expect_type(522)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(523)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _tmp_172(self): # type Optional[Any]
        # _tmp_172: 'as' NAME
        mark = self._mark()
        literal = self.expect_type(521)
        if literal:
            name = self.name()
            if name:
                return [literal, name]
        self._reset(mark)
        return None

    @logger
    def _tmp_173(self): # type Optional[Any]
        # _tmp_173: 'as' NAME
        mark = self._mark()
        literal = self.expect_type(521)
        if literal:
            name = self.name()
            if name:
                return [literal, name]
        self._reset(mark)
        return None

    @logger
    def _tmp_174(self): # type Optional[Any]
        # _tmp_174: 'as' NAME
        mark = self._mark()
        literal = self.expect_type(521)
        if literal:
            name = self.name()
            if name:
                return [literal, name]
        self._reset(mark)
        return None

    @logger
    def _tmp_175(self): # type Optional[Any]
        # _tmp_175: positional_patterns ','
        mark = self._mark()
        positional_patterns = self.positional_patterns()
        if positional_patterns:
            literal = self.expect_type(12)
            if literal:
                return [positional_patterns, literal]
        self._reset(mark)
        return None

    @logger
    def _tmp_176(self): # type Optional[Any]
        # _tmp_176: '->' expression
        mark = self._mark()
        literal = self.expect_type(52)
        if literal:
            expression = self.expression()
            if expression:
                return [literal, expression]
        self._reset(mark)
        return None

    @logger
    def _tmp_177(self): # type Optional[Any]
        # _tmp_177: '(' arguments? ')'
        mark = self._mark()
        literal = self.expect_type(7)
        if literal:
            opt = self.arguments()
            if True:
                literal_1 = self.expect_type(8)
                if literal_1:
                    return [literal, opt, literal_1]
        self._reset(mark)
        return None

    @logger
    def _loop0_179(self): # type Optional[Any]
        # _loop0_179: ',' double_starred_kvpair
        mark = self._mark()
        children = []
        while True:
            literal = self.expect_type(12)
            if not literal:
                break
            elem = self.double_starred_kvpair()
            if not elem:
                break
            children.append(elem)
            mark = self._mark()
        self._reset(mark)
        return children

    @logger
    def _gather_178(self): # type Optional[Any]
        # _gather_178: double_starred_kvpair _loop0_179
        mark = self._mark()
        elem = self.double_starred_kvpair()
        if elem is not None:
            seq = self._loop0_179()
            if seq is not None:
                return [elem] + seq
        self._reset(mark)
        return None

    @logger
    def _tmp_180(self): # type Optional[Any]
        # _tmp_180: '}' | ','
        mark = self._mark()
        literal = self.expect_type(27)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(12)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _tmp_181(self): # type Optional[Any]
        # _tmp_181: star_targets '='
        mark = self._mark()
        z = self.star_targets()
        if z:
            literal = self.expect_type(22)
            if literal:
                return z
        self._reset(mark)
        return None

    @logger
    def _tmp_182(self): # type Optional[Any]
        # _tmp_182: '.' | '...'
        mark = self._mark()
        literal = self.expect_type(23)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(53)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _tmp_183(self): # type Optional[Any]
        # _tmp_183: '.' | '...'
        mark = self._mark()
        literal = self.expect_type(23)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(53)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _tmp_184(self): # type Optional[Any]
        # _tmp_184: ',' expression
        mark = self._mark()
        literal = self.expect_type(12)
        if literal:
            c = self.expression()
            if c:
                return c
        self._reset(mark)
        return None

    @logger
    def _tmp_185(self): # type Optional[Any]
        # _tmp_185: ',' star_expression
        mark = self._mark()
        literal = self.expect_type(12)
        if literal:
            c = self.star_expression()
            if c:
                return c
        self._reset(mark)
        return None

    @logger
    def _tmp_186(self): # type Optional[Any]
        # _tmp_186: 'or' conjunction
        mark = self._mark()
        literal = self.expect_type(530)
        if literal:
            c = self.conjunction()
            if c:
                return c
        self._reset(mark)
        return None

    @logger
    def _tmp_187(self): # type Optional[Any]
        # _tmp_187: 'and' inversion
        mark = self._mark()
        literal = self.expect_type(531)
        if literal:
            c = self.inversion()
            if c:
                return c
        self._reset(mark)
        return None

    @logger
    def _tmp_188(self): # type Optional[Any]
        # _tmp_188: 'if' disjunction
        mark = self._mark()
        literal = self.expect_type(509)
        if literal:
            z = self.disjunction()
            if z:
                return z
        self._reset(mark)
        return None

    @logger
    def _tmp_189(self): # type Optional[Any]
        # _tmp_189: 'if' disjunction
        mark = self._mark()
        literal = self.expect_type(509)
        if literal:
            z = self.disjunction()
            if z:
                return z
        self._reset(mark)
        return None

    @logger
    def _tmp_190(self): # type Optional[Any]
        # _tmp_190: starred_expression | (assignment_expression | expression !':=') !'='
        mark = self._mark()
        starred_expression = self.starred_expression()
        if starred_expression:
            return starred_expression
        self._reset(mark)
        _tmp_201 = self._tmp_201()
        if _tmp_201:
            
            if self.negative_lookahead(self.expect_type, 22):
                return _tmp_201
        self._reset(mark)
        return None

    @logger
    def _tmp_191(self): # type Optional[Any]
        # _tmp_191: ',' star_target
        mark = self._mark()
        literal = self.expect_type(12)
        if literal:
            c = self.star_target()
            if c:
                return c
        self._reset(mark)
        return None

    @logger
    def _tmp_192(self): # type Optional[Any]
        # _tmp_192: ',' star_target
        mark = self._mark()
        literal = self.expect_type(12)
        if literal:
            c = self.star_target()
            if c:
                return c
        self._reset(mark)
        return None

    @logger
    def _tmp_193(self): # type Optional[Any]
        # _tmp_193: star_targets '='
        mark = self._mark()
        star_targets = self.star_targets()
        if star_targets:
            literal = self.expect_type(22)
            if literal:
                return [star_targets, literal]
        self._reset(mark)
        return None

    @logger
    def _tmp_194(self): # type Optional[Any]
        # _tmp_194: star_targets '='
        mark = self._mark()
        star_targets = self.star_targets()
        if star_targets:
            literal = self.expect_type(22)
            if literal:
                return [star_targets, literal]
        self._reset(mark)
        return None

    @logger
    def _tmp_195(self): # type Optional[Any]
        # _tmp_195: ')' | '**'
        mark = self._mark()
        literal = self.expect_type(8)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(36)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _tmp_196(self): # type Optional[Any]
        # _tmp_196: ':' | '**'
        mark = self._mark()
        literal = self.expect_type(11)
        if literal:
            return literal
        self._reset(mark)
        literal = self.expect_type(36)
        if literal:
            return literal
        self._reset(mark)
        return None

    @logger
    def _tmp_197(self): # type Optional[Any]
        # _tmp_197: expression ['as' star_target]
        mark = self._mark()
        expression = self.expression()
        if expression:
            opt = self._tmp_202()
            if True:
                return [expression, opt]
        self._reset(mark)
        return None

    @logger
    def _tmp_198(self): # type Optional[Any]
        # _tmp_198: expressions ['as' star_target]
        mark = self._mark()
        expressions = self.expressions()
        if expressions:
            opt = self._tmp_203()
            if True:
                return [expressions, opt]
        self._reset(mark)
        return None

    @logger
    def _tmp_199(self): # type Optional[Any]
        # _tmp_199: expression ['as' star_target]
        mark = self._mark()
        expression = self.expression()
        if expression:
            opt = self._tmp_204()
            if True:
                return [expression, opt]
        self._reset(mark)
        return None

    @logger
    def _tmp_200(self): # type Optional[Any]
        # _tmp_200: expressions ['as' star_target]
        mark = self._mark()
        expressions = self.expressions()
        if expressions:
            opt = self._tmp_205()
            if True:
                return [expressions, opt]
        self._reset(mark)
        return None

    @logger
    def _tmp_201(self): # type Optional[Any]
        # _tmp_201: assignment_expression | expression !':='
        mark = self._mark()
        assignment_expression = self.assignment_expression()
        if assignment_expression:
            return assignment_expression
        self._reset(mark)
        expression = self.expression()
        if expression:
            
            if self.negative_lookahead(self.expect_type, 54):
                return expression
        self._reset(mark)
        return None

    @logger
    def _tmp_202(self): # type Optional[Any]
        # _tmp_202: 'as' star_target
        mark = self._mark()
        literal = self.expect_type(521)
        if literal:
            star_target = self.star_target()
            if star_target:
                return [literal, star_target]
        self._reset(mark)
        return None

    @logger
    def _tmp_203(self): # type Optional[Any]
        # _tmp_203: 'as' star_target
        mark = self._mark()
        literal = self.expect_type(521)
        if literal:
            star_target = self.star_target()
            if star_target:
                return [literal, star_target]
        self._reset(mark)
        return None

    @logger
    def _tmp_204(self): # type Optional[Any]
        # _tmp_204: 'as' star_target
        mark = self._mark()
        literal = self.expect_type(521)
        if literal:
            star_target = self.star_target()
            if star_target:
                return [literal, star_target]
        self._reset(mark)
        return None

    @logger
    def _tmp_205(self): # type Optional[Any]
        # _tmp_205: 'as' star_target
        mark = self._mark()
        literal = self.expect_type(521)
        if literal:
            star_target = self.star_target()
            if star_target:
                return [literal, star_target]
        self._reset(mark)
        return None

    KEYWORD_INDICES = {'return': 499, 'raise': 500, 'pass': 501, 'del': 502, 'yield': 503, 'assert': 504, 'break': 505, 'continue': 506, 'global': 507, 'nonlocal': 508, 'if': 509, 'try': 510, 'while': 511, 'import': 512, 'from': 513, 'class': 514, 'def': 515, 'elif': 516, 'else': 517, 'for': 518, 'in': 519, 'with': 520, 'as': 521, 'except': 522, 'finally': 523, 'None': 524, 'True': 525, 'False': 526, 'not': 527, 'is': 528, 'lambda': 529, 'or': 530, 'and': 531}
    KEYWORDS = ('False', 'None', 'True', 'and', 'as', 'assert', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield')
    SOFT_KEYWORDS = ('_', 'case', 'match')

