* int_add - IMM
* int_cmp - IMM
* guard_nonnull_class - think about a better way
* cond_call and following guard_exception
* stack check


* We can try to make generate_quick_failure() emit two instructions less:
  the two store_reg() [one in generate_quick_failure and the other in
  push_gcmap].  Instead we'd load the values in ip2 and ip3, and the
  store_regs would occur inside self.failure_recovery_code
  (which 'target' points to).


* use STP instead of STR in all long sequences of STR.  Same with LDR

* use "STR xzr, [..]" instead of "gen_load_int(ip, 0); STR ip, [..]".
  Search around for gen_load_int(...0): it occurs at least in pop_gcmap()
  _build_failure_recovery(), build_frame_realloc_slowpath(), etc.


* here's what gcc uses to acquire and release a lock, instead of mc.DMB
  in callbuilder.py.  It would make the control flow mess easier, too,
  because we can simply loop back to .L2 (rare case) instead of trying
  to handle it as a 3rd path.
  - to release a lock:
                (x0 is the address of the lock)
                stlr xzr, [x0]
  - to acquire a lock:
                (x1 is the address of the lock)
                mov x2, 1
           .L2: ldxr x0, [x1]
                stxr w3, x2, [x1]
                cbnz w3, .L2   (I think it's a rare case when it follows .L2)
                dmb ish        (see below)
                (we're left with x0 being the old value in the lock, 0 or 1)
  - note that "dmb" only appears sometimes, depending on the exact gcc
    intrinsic I use.  I *think* that it can be safely removed, and so
    it should be.


* malloc_cond() and malloc_cond_varsize_frame() hard-code forward jump
  distances by guessing the number of instructions that follows.  Bad
  idea because some of these instructions could easily be optimized in
  the future to be a bit shorter.  Rewrite this two places to use the
  proper way instead of a magic "40" (or at least assert that it was
  really 40).


* use "CBNZ register, offset" (compare-and-branch-if-not-zero)
  instead of a CMP+BNE pair.  Same with CBZ instead of CMP+BEQ


* when we need to save things on the stack, we typically push two words
  and pop them later.  It would be cheaper if we reserved two locations
  in the stack from _call_header, then we could just write there.
  *OR*
  maybe it's enough if we use the form "str x0, [sp, !#offset]" which
  combines in a single instruction the "str" with the change of sp
