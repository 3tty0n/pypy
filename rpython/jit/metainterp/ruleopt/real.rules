add_reassoc_consts: int_add(int_add(x, C1), C2)
    C = C1 + C2
    => int_add(x, C)

add_zero: int_add(x, 0)
    => x


sub_zero: int_sub(x, 0)
    => x

sub_from_zero: int_sub(0, x)
    => int_neg(x)

sub_x_x: int_sub(x, x)
    => 0

sub_add_consts: int_sub(int_add(x, C1), C2)
    C = C2 - C1
    => int_sub(x, C)

sub_add: int_sub(int_add(x, y), y)
    => x



and_zero: int_and(a, 0)
    => 0

and_x_x: int_and(a, a)
    => a

and_minus_1: int_and(x, -1)
    => x

and_reassoc_consts: int_and(int_and(x, C1), C2)
    C = C1 & C2
    => int_and(x, C)

and_x_c_in_range: int_and(x, C)
    check x.lower >= 0 and x.upper <= C & ~(C + 1)
    => x

and_x_y_covered_ones: int_and(x, y)
    # int_and(x, y) == x if the 1s in y cover all 1s and all ?s in x
    check ~y.tvalue & (x.tmask | x.tvalue) == 0
    => x


#and_known_result: int_and(a, b)
#    check a.and_bound(b).is_constant()
#    C = a.and_bound(b).get_constant_int()
#    => C
#
#
xor_x_x: int_xor(a, a)
    => 0

xor_absorb: int_xor(int_xor(a, b), b)
    => a

xor_zero: int_xor(a, 0)
    => a

xor_minus_1: int_xor(x, -1)
    => int_invert(x)



eq_different_knownbits: int_eq(x, y)
    SORRY_Z3
    check x.known_ne(y)
    => 0

eq_same: int_eq(x, x)
    => 1

eq_one: int_eq(x, 1)
    check x.is_bool()
    => x

eq_zero: int_eq(x, 0)
    => int_is_zero(x)


ne_different_knownbits: int_ne(x, y)
    SORRY_Z3
    check x.known_ne(y)
    => 1

ne_same: int_ne(x, x)
    => 0

ne_zero: int_ne(x, 0)
    => int_is_true(x)



force_ge_zero_pos: int_force_ge_zero(x)
    check x.known_nonnegative()
    => x

force_ge_zero_neg: int_force_ge_zero(x)
    check x.known_lt_const(0)
    => 0

invert_invert: int_invert(int_invert(x))
    => x
#
#
#sub_zero: int_sub(x, 0)
#    => x
#
#sub_from_zero: int_sub(0, x)
#    => int_neg(x)
#
#sub_x_x: int_sub(x, x)
#    => 0
#
#sub_add_consts: int_sub(int_add(x, C1), C2)
#    C = C2 - C1
#    => int_sub(x, C)
#
#sub_add: int_sub(int_add(x, y), y)
#    => x
#
#lshift_rshift_c_c: int_lshift(int_rshift(x, C1), C1)
#    check 0 <= C1 and C1 < LONG_BIT
#    C = (-1 >>a C1) << C1
#    => int_and(x, C)
#
#lshift_lshift_c_c: int_lshift(int_lshift(x, C1), C2)
#    check 0 <= C1 and C1 < LONG_BIT and 0 <= C2 and C2 < LONG_BIT
#    C = C1 + C2
#    check C < LONG_BIT
#    => int_lshift(x, C)
#
#neg_neg: int_neg(int_neg(x))
#    => x
#
#invert_invert: int_invert(int_invert(x))
#    => x
#
#or_minus_1: int_or(x, -1)
#    => -1
#
#or_x_x: int_or(a, a)
#    => a
#
#or_absorb: int_or(a, int_or(a, b))
#    => int_or(a, b)
#
#
#
#xor_x_y_sub_y: int_sub(int_xor(x, y), y)
#    # (x ^ y) - y == x if x & y == 0
#    check x.and_bound(y).known_eq_const(0)
#    => x
#
#mul_zero: int_mul(x, 0)
#    => 0
#
#mul_one: int_mul(x, 1)
#    => x
#
#mul_minus_one: int_mul(x, -1)
#    => int_neg(x)
#
#mul_neg_neg: int_mul(int_neg(x), int_neg(y))
#    => int_mul(x, y)
#
#mul_lshift: int_mul(x, int_lshift(1, y))
#    check y.known_ge_const(0) and y.known_le_const(LONG_BIT)
#    => int_lshift(x, y)
#
#mul_pow2_const: int_mul(x, C)
#    check C > 0 and C & (C - 1) == 0
#    shift = highest_bit(C)
#    => int_lshift(x, shift)
